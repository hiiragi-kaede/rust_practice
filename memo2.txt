10.ジェネリック型、トレイト、ライフタイムから

ジェネリック型を活用することで引数の型のみが違う重複した動きの関数を一つにまとめ上げることが出来る。
i32のスライスから最大のi32を探す関数と、スライスから最大のcharを探す関数を一緒のものに出来る。
例えば
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}
のような感じに。
これは比較演算子が定義されていればどんな型にも活用できる。
ので、逆にこのまま使うと比較演算子がTに対して実装されていないというコンパイルエラーが出る。
解決法はトレイトの話になるのでまた後で。

構造体にジェネリックな型引数を使用することが出来る。
struct Point<T>{
    x: T,
    y: T,
}
こうすれば任意の同じ型を2つ保存する構造体が作れる。
当然xとyの型は同じでなければならないので、i32とf32とかで2つを保存したりはできない。

違う型で保存したい場合はジェネリック型を2つ使うことで出来る。
struct Point<T,U>{
    x: T,
    y: U,
}
この場合、T=Uでも問題なく動くし、TとUが違う型でも動く。

struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

ジェネリックな型を使うメソッドを構造体やenumに実装することも出来る。
implの直後にTを宣言しなければならないことに注意。
implの後にTをジェネリックな型として宣言することで、コンパイラはPointの山カッコ内の型が、ジェネリックな型であることを認識できる。

例えばジェネリックな型を取る構造体に関して、指定の型だけにメソッドを定義したりも出来る。
imple Point<f32>{
    fn distance_from_origin(&self) -> f32{
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
みたいな感じ。


struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}
複数のジェネリック型を扱うときにはこのようなことができる。
ここで注意なのはPoint構造体はT,Uを定義しているため、implの直後に宣言するのはそちらであり、V,Wの方ではないということ。
V,Wはこのメソッドにしか関係のないジェネリック型。

ジェネリクスを使う場合でもパフォーマンスが悪くならないために、コンパイル時にジェネリック型に具体的な型を埋め込むようにしている。
