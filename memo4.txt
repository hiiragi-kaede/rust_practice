16,恐れるな並行性（スレッド処理について）から


多くの現代のOSでは実行中のプログラムのコードはプロセスで走り、OSは同時に複数のプロセスを管理する。
自分のプログラム内で独立した部分を同時に実行することが出来る。これらの独立した部分を走らせる機能をスレッドと呼ぶ。

プログラム内の計算を複数のスレッドに分けると、パフォーマンスが改善されるが、複雑度も増す。
スレッドは同時に走らせることが出来るので、走る順番に関して保証されない。これにより以下のような問題が起こる。
・スレッドがデータやリソースに矛盾した順番でアクセスする競合状態
・2つのスレッドがお互いにもう一方の所有するリソースの使用し終わるのを待つ状態になり、デッドロックになる
・特定の状況でのみ起き、確実な再現や修正が困難なバグ

多くのOSでは新規スレッドを生成するAPIを提供している。言語がOSのAPIを呼び出してスレッドを生成するこのモデルを1:1と呼び、
一つのOSスレッドに対して一つの言語スレッドを意味する。

プログラミング言語が提供するスレッドはグリーンスレッドと知られ、このグリーンスレッドを使用する言語はそれを異なる数のOSスレッドの文脈で実行する。
そのため、グリーンスレッドのモデルはM:Nモデルと呼ばれる。
M個のグリーンスレッドに対してN個のOSスレッドがあり、MとNは必ずしも同じ数字ではない。

各モデルには利点と代償があり、Rustにとって最も重要な代償はランタイムのサポート。
この文脈でのランタイムとは、言語によって全てのバイナリに含まれるコードのことを意味する。
Rustにはほぼゼロのランタイムが必要でパフォーマンスを維持するためにCコードを呼び出せることを妥協できない。

M:Nのグリーンスレッドモデルはスレッドを管理するのにより大きな言語ランタイムが必要。
そのためにRustの標準ライブラリは1:1スレッドの実装のみを提供している。
どのスレッドがいつ走るかのより詳細の制御や、より低コストの文脈切り替えなどの一面をオーバーヘッドと引き換えるなら、
M:Nスレッドの実装をしたクレートもある。

新規スレッドを生成するには、thread::spawn関数を呼び出し、新規スレッドで走らせたいコードを含むクロージャを渡す。

use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            // やあ！立ち上げたスレッドから数字{}だよ！
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        // メインスレッドから数字{}だよ！
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}

この関数では、新しいスレッドは実行が終わったかどうかに関わらず、メインスレッドが終了したら停止することに注意。
thread::sleepを呼び出すと、少々の間スレッドの実行を止め、違うスレッドを走らせることが出来る。
スレッドはおそらく切り替わると思われるが、保証はない。
上のコードではメインスレッドが終了するために、殆どの場合立ち上げたスレッドが全て実行されないだけでなく、
立ち上げたスレッドが実行されるかどうかも保証できない。

thread::spawnの戻り値を変数に保存することで、立ち上げたスレッドが実行されなかったり、完全には実行されなかったりする問題を修正できる。
thread::spawnの戻り値の型はJoinHandleになる。JoinHandleはそのjoinメソッドを呼び出したときにスレッドの終了を待つ所有された値。
上のコードを
let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

と修正することで、問題を解決できる。
ハンドルに対してjoinを呼び出すと、ハンドルが表すスレッドが終了するまで現在実行中のスレッドをブロックする。
スレッドをブロックするとは、そのスレッドが動いたり、終了したりすることを防ぐこと。
joinの呼び出しをメインスレッドのforループの後に配置したので、メインスレッドの処理が終わった後もhandleの出力が終わるまで終了されなくなる。

joinメソッドの呼び出しを、メインスレッドでのforループの前に配置すると、handleスレッドのforループを完遂した後にメインスレッドのループを実行する。
このように、joinの呼び出しタイミングにより実行順序に影響してくる。

use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        // こちらがベクタ: {:?}
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}

このように立ち上げたスレッドでメインスレッドのデータを使用するためには、立ち上げるスレッドのクロージャは必要な値をキャプチャしなければならない。
上のコードではまだ動かない。
上のコードではvを借用しようとするが、立ち上げたスレッドがどのくらいの期間走るかわからないので、vへの参照が常に有効であるか把握できない。

use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}

コンパイルエラーに従ってmoveキーワードを付けることにより、クロージャに使用している値の所有権を強制的に奪わせることが出来る。
クロージャに値をmoveした場合、借用規則によりメインスレッドではもはやvの値を使うことはできなくなる。