println!はRustのマクロを呼び出す。
！を使うと、普通の関数ではなくマクロを読んでいるということを知っておこう。

cargoはnpmみたいな感じでライブラリとかのバージョン管理を行ってくれる。
cargo new <project_name> --bin
とかで新規プロジェクトを作れる。
cargo check でエラーをチェックし、実際ビルドが必要なときには
cargo build →./target/debug/<project_name>
もしくは　cargo run
でできる。

cargo build --releaseを使うと最適化を行ってコンパイルできる。
このときはコンパイルに時間がかかるようになるため回数は少ないほうが良い。

cargo.lockによって破壊的アップデートがあったとしても、明示的にアップグレードしなければ再現可能なビルドを構成してくれる。


不変変数と定数がどちらも存在している。
不変変数はletで、定数はconstで宣言する。
定数は必ず型を必ず注釈しなければならず、グローバルスコープを含めてどこのスコープでも定義できる。
定数は定数式にしかセットできず、関数呼び出し結果や実行時に評価される値にはセットできない。
Rustの定数の命名規則としては全て大文字で、アンダースコアで単語区切りすること。

可変変数はシャドーイングにより定義し直すことで型や値を変更できるが、mutによって型を変更することは許されていない。

Rustにおける値は全て何らかのデータ型になっている。Rustは静的型付き言語であるので、コンパイル時にすべての変数の型が判明している必要がある。
コンパイラは値と使用方法に基づいて型を推論してくれる。parseメソッドのように変換先が複数の型が可能な場合には、変数に型注釈をつけなければいけない。

整数型は符号付きと符号無しで、8bitの大きさの変数としてi8とu8のような感じで存在する。8~64bitまである。
整数リテラルは他言語と同じ感じ。アンダーバーを見た目の区切り記号として使うことができる。
10進数→98222
16進数→0xff
8進数→0o77
2進数→0b1111_0000
バイト→b'A'

浮動小数点型はf32とf64があるが、基準型はf64になる。
let x =2.0; ならf64
let y: f32 = 3.0; ならf32になる。
論理値型はtrueとfalseの2つしかない。
文字型としてchar型があるが、こちらはダブルクオーテーションを使う文字列に対して、シングルクォートで指定される。

複合型としてタプルなどがある。
タプルはlet tup = (500,6.4,1)
(型注釈をわざわざつけると　let tup: (i32, f54, u8) = (500,6.4,1))
タプルはすべての型を揃える必要はない。

タプルから個々の値を取り出すにはパターンマッチングを使用して分解することができる。
let (x,y,z) = (500,6.4,1)
println!("value:{}",y);
みたいな感じ。

タプルの要素へのアクセスはパターンマッチング以外にも添え字アクセスができる。
とはいえ添字アクセスにはピリオドを使うことでタプルの要素に直接アクセスすることができる。
x.0とかx.1など。
ちなみに添字は0始まり。

配列は固定長なので、一度宣言されたらサイズを伸ばすことも縮めることもできない。
let a = [1,2,3,4,5]
角括弧内にカンマ区切りリストとして記述する。
配列はヒープよりもスタックにデータのメモリを確保したいときに有効。
配列とベクタ型があるが、大抵の場合はベクタ型を使うべき。ベクタはサイズを伸縮させることができる。まあC++のやつと同じということみたい。
こっちのアクセスはx[0]とかx[1]みたいないつものアクセス方法。
配列外参照をすると実行時エラーが起こり、言語はパニックする。
パニックとはプログラムがエラーで終了したことを表すRust用語。

Rustの関数はfn <関数名>(){}　みたいな感じで宣言できる。
Rustの関数と変数の命名規則はスネークケースを使うのが慣例。
コンパイラは関数がどこで定義されているかを気にせず、どこかで定義されているかどうかのみを気にする。

関数の引数を追加するときには、各仮引数の型を宣言しなければならない。
fn sample_func(x: i32,y: i64)
みたいな感じで複数の引数に対してはコンマで区切って指定する。

Rustではx=y=6みたいな文法は許されていない。代入文は値を返さないためこうなる。
let y ={
    let ret = sample_func()
    ret*2 + 1
};
みたいな感じでブロックで代入できる。この場合最後の行は文末にセミコロンがついていないことに注意。

戻り値のある関数は他の言語と違った記法になっている。
fn five() -> i32{
    5
}
fn main(){
    let x = five();
}
みたいな感じ。戻り値に名前をつけはしないが矢印のあとに型を書いて宣言する。
returnキーワードで値を指定することもできるが、多くの関数は最後の式を暗黙的に返す。

Rustにおけるコメントは全部//。複数行にまたがる場合は全部に//をつける。

if文はGoみたいなかんじ。条件式にカッコを付けなくても大丈夫。
条件式はbool型でないといけないことにも注意。
else ifが増えすぎると見にくくなってしまうので、多すぎる場合はmatchと呼ばれる文法を使用すること推奨。

let文内でif文を使うこともでき、
let num = if condition{
    5
}else{
    4
};
みたいに使う。
注意点としては、この使い方をするときはifとelseで代入する値の型を同じにしないとコンパイルエラーが出る。

loop{}
で簡単に無限ループを作れる。この場合ctrl+c使わないと中断させられないので注意（もしくはbreakするかか？）

while cnt!=0{
    func();
    cnt = cnt-1;
}
みたいな感じでいつものようにwhileループを作れる。

let a = [10,20,30,40,50];

for ele in a.iter(){
    println!("the number is {}",ele);
}
みたいな感じでforループを作成できる。

for number in (1..4).rev(){
    println!("{}",number);
}
でカウントダウンを作れる

コンパイル時にサイズが分かるものはスタックに。
コンパイル時にサイズがわからなかったり、サイズが可変のデータはヒープに置かれる。
スタックはデータを探す段階が存在しないため、ヒープのデータアクセスよりも高速。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Rustの所有権の規則は以下の通り。
・Rustの各値は、所有者と呼ばれる変数と対応している。
・いかなる時も所有者は一つである。
・所有者がスコープから外れたら、値は破棄される。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

文字列リテラルは不変であり、入力を受け付けて保持したいときなどには使えない。
そのためにString型がある。
String型はヒープにメモリを確保するので、コンパイル時にはサイズが不明なテキストも保持することができる。

let s = String::from("hello");

こういった文字列は可変化することができる。
let mut s = String::from("hello");
s.push_str(",world!");
println!("{}",s);


文字列リテラルの場合、中身はコンパイル時に判明しているので、テキストは最終的なバイナリファイルに直接ハードコードされる。
そのため、文字列リテラルは高速で効率的になる。
一方で、サイズが既知であったり、不変であるからこの強みが活かせるのであり、使いにくい場面もある。

C++などではメモリを要求する場合はallocateとfreeを完璧に一対一に対応させなければならないが、Rustは違う。
メモリを所有している変数がスコープを抜けたときにメモリを自動的に返還する。
スコープを抜ける際にdropと呼ばれる関数を自動的に呼ぶ。

let s1 = String::from("hello");
let s2 = s1;

これは保存先のヒープへのポインタをs2が保持する。
つまり、スタックにあるポインタ・長さ・許容量をコピーし、ポインタが指すヒープ上のデータはコピーしない。
これらがそのままスコープを抜けるとs1とs2を開放しようとするが、これは二重開放になってしまう。
そのため、Rustではこのようなことをしたときにs2にs1を代入したときにs1を無効化する。
つまりs2にs1をムーブする。s2だけが有効になっているので、s2を開放して安全に開放される。

ムーブでなく深いコピーをしたいときにはcloneメソッドを活用する。
let s1 = String::from("hello");
let s2 = s1.clone();
これならs1もs2もスコープ内で使用でき、スコープを抜けたときに2つとも開放される。

整数のようなコンパイル時に既知のサイズを持つ型は、ムーブではなくコピーされる。
大抵は無効にする必要性が皆無なため。
これはCopyトレイトと呼ばれる注釈がついている。（トレイトはよくわかっていないのであってるか不明）

Copyとなる型は以下のようなもの（全部ではない）
・u32などの整数型。
・bool型
・f64などの浮動小数点型。
・文字列であるchar
・Copyの型だけを含むタプル。


Copyトレイトでない型を関数に渡すと、所有権が渡され元の変数は使えなくなる。
元の変数を使った時点でコンパイルエラーが出るのでまあ安心か。
値を返す関数によっても所有権が移動する。

関数に渡すときにいちいち所有権が渡されるのがめんどくさいときは参照で渡すことができる。
&s1　で渡して　s: &String　みたいな感じで受け取る

参照で渡したものを変更することはできない。変数が標準で不変なのと同様に参照も不変。
これを変更したいときには一捻りを加えるだけでOK。

change(&mut s);
fn change(str: &mut String){}

一つ重要な点として、特定のスコープでは、同じデータに対して一つしか可変な参照を持てない。

let mut s = String::from("hello");

let r1 = &s; // 問題なし
let r2 = &s; // 問題なし
let r3 = &mut s; // 大問題！

このように、可変と不変な参照を組み合わせることに関しても厳しく取り締まられている。
不変な参照をしている間は可変な参照をすることができない。しかし、読み込むだけである不変参照を複数作ることには制約は存在しない。

Stringの値を要素ごとに見るためにはas_bytesメソッドを使うことでStringオブジェクトをバイト配列に変換している。
とはいえこのやり方ではStringオブジェクトと添字が一致して更新されないので（求めてからStringをクリアできてしまう）、困る。

fn main() {
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
}
このようにRustではスライスはこのように書く。
[0:5]はPythonとかGoで、Rustは[0..5]
これはStringの一部への参照を作成している。他言語と同じく後ろの添字までは含まない（[0..5]は0~4までのサイズ5）
Pythonと同じく、自明なら添字を省略できる
[0..2] = [..2]
[3..len] = [3..]
[0..len] = [..]

文字列スライスを意味する方は&strになる。
文字列スライスがあるとき、不変な参照が存在している。つまり、不変参照が存在している間可変な参照は得られないので、安全に使うことができる。

文字列リテラルの型は&strになっている。そのため文字列は不変になっている。
また、Stringの値と&strを両方扱える関数にするためには、引数の型を&strにするとよい。
文字列リテラルを渡すときにはそのままでよく、Stringを渡すときには&my_string[..]にすれば問題なく動かすことができる。


構造体の定義は
struct User{
    username: String,
    email: String,
    active: bool,
}
みたいにする。

使用時には
let user1 = User{
  username: String::from("TAS"),
  email: String::from("sample@example.com"),
  active: true,
};
みたいにする。

ちなみに、初期化順は構造体で宣言した通りの順番に指定する必要はない。

構造体から特定の値を得るのはドット記法。つまりいつもの。
インスタンスが可変であればドット記法で代入することができる。
let mut user1={...};
user1.email = String::from("another@example.com")

インスタンス全体が可変でなければならない！Rustでは一部のフィールドのみを可変にすることはできない。
いわゆるコンストラクタのbuild関数を作るときに、関数の最後で構造体を生成すればそれをreturnしてくれる。
そのとき、フィールドと引数の値が同じ時はemail:emailみたいに書く必要はなく、emailと書くだけでよい。
ちなみに大文字小文字でも動かなくなるので、本当にフィールドと一致させないとだめ。

error[E0560]: struct `User` has no field named `Email`
  --> main.rs:14:9
   |
14 |         Email,
   |         ^^^^^ help: a field with a similar name exists: `email`


let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
こんな感じで同じ構造体のインスタンスのフィールドを活用して初期化できる。

let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};

また、上のような構造体更新記法を使うと、明示的にセットされていない残りのフィールドを、与えられたインスタンスのフィールドと同じ値になるように指定する。

構造体名により追加の意味を含むものの、フィールドに名前を持たずフィールドの型だけのタプル構造体が存在する。
struct Color(i32, i32, i32);
let black = Color(0, 0, 0);

タプル構造体は同じ数の同じ型からできていたとしても互換性はない。意味が違うから当然といえば当然だが。
インスタンスはタプルと同じように振る舞うので、分配して個々の部品にしたり、ドットと添字を使用して個々の値にアクセスして使ったりできる。

一切フィールドのない構造体を定義することもできる。
これはユニット型と似たような振る舞いをするのでユニット様構造体と呼ばれる。
ある型にトレイトを実装するけども、型自体に保持させるデータは一切ない場面に有効になる。
トレイトの話はまだなのでよくわかってない。

構造体の宣言時に#[derive(Debug)]
を追加することによって、println!("{:?}")という形で出力形式を定義しなくとも表示させることが可能になる。
また、{:#?}を代わりに使うことにより、改行が入り、見やすくなる。


#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}

ある構造体のクラスメソッドとして定義するためには、implブロックを始め、その中で関数を定義する。
また、それらの関数の第一引数は必ずselfになる。
selfの方が構造体の型であることがわかっているため、不変でselfを借用したり、可変でselfを借用したりできる。つまり、他の引数と同じ。

Rustでは自動参照および参照外しという機能があり、メソッド呼び出しを行うときに自動で&、&mut、*を付与してくれる。

implブロックの中では、selfを引数に取らない関数を定義することができる。これは構造体自体に関連付けられているので、関連関数と呼ばれる。
この関連関数は構造体の新規インスタンスを返すコンストラクタによく使用される。
関連関数の呼び出しは::を使用する。
let sq = Rectangle::square(3);
みたいな感じで使う。これまで使ったものだとString::from()とかも関連関数。

implブロックは同じ構造体に対してでも、分割して書くことができる。


RustのEnumはstructと同じように宣言する
enum IpAddrKind{
    V4,
    V6,
}
列挙型なので、あり得る状態をすべて表せるときに使う。
使用時は
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
また、関数を列挙子の全てに対応させられる。
fn route(ip_type: IpAddrKind){ }

ただし、このままだと実際のデータを保持できない。そこで、enumの値と結び付けられる値をともに保存できる。

enum IpAddr{
    V4(String),
    V6(String),
}
let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));

enumの各列挙子にデータを直接添付できるので、余計な構造体を作る必要はない。
また、各列挙子に紐付けるデータの型は異なっても良い。
それどころか各列挙子に紐付ける型を構造体にすることで無限の可用性がある。

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

こんな感じで多様な種類の命令を列挙型として定義できる。

enumもimplを用いてenumにもメソッドを定義することができる。

enumで有用なものとして、Optionが存在する。

enum Option<T> {
    Some(T),
    None,
}
定義としてはこれだけ。他言語のnullの処理に相当するもの。

let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;

こんな感じで使う。注意点としてはNoneを指定するときは必ずOption<T>の型が何になるかを教えなければならない。
値が存在する時、Someに保持されている。一方で、None値がある時nullと同じことを意図する。

Option<T>とTは型が違うためにコンパイルがうまくいかなくなるため、値を使う前にnullであることをチェックする必要がなくなる。
つまり、値を保持していない可能性を心配する必要がなくなる。
nullになる可能性のある値を保持するためにはその値の方をOption<T>にすることで明示的に同意しなければならない。


match式
match式はif文に似ているが、渡すものがboolでなくても構わない。
match文の直後に続くものによって分岐し、=>の後で指定された処理が実行される。
短い内容であれば{}は省略される。

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

enumが値を持つ場合でも、同じようにmatch文を使うことができ、
match coin{
    Coin::Quarter(state) =>{
        println!("{:?}",state);
    }
}
のように今回の場合ではstateに値を束縛することができる。

先ほど出てきたOption<T>とmatch文の相性はとてもよく、合わせて使われることが多い。

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

こんな形でエラー処理ができるためすごく楽。
また、match文は全部の可能性を網羅していなければコンパイルエラーを生み出してくれる。
Option<T>に対してNoneの場合を取り扱っていなければエラー出してくれるのはすごく偉い。

また、それ以外の場合全てという意味を現したいときにはアンダーバーを活用する。
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}


また、一つのパターンにのみ注目したい場合match文は冗長なので、if letを使うことができる。

if let Some(3) = some_u8_value{
    println!("this is three");
}

これにより簡単に書けるようになるが、matchでは強制された包括性チェックを失ってしまう。
つまり簡潔性と包括性チェックはトレードオフの関係にある。

matchにおける_に対応して、elseを使うこともできる。
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}


モジュールはmodキーワードを書き、次にモジュールの名前を指定することで定義する。
また、モジュールの中には他のモジュールを置くこともできる。
モジュールツリー全体が、暗黙のうちに作られたcrateというモジュールの下にある。

モジュールの中で公開するAPIについてはpubキーワードを付ける。
また、デフォルトではモジュールはprivateなので、関数や構造体を非公開にしたければモジュールに入れれば良い。

親モジュールの要素は子モジュールの非公開要素を使えないが、子モジュールの要素はその祖先モジュールの要素を使える。
注意すべきはモジュール自体をpubにしたところで、中身を公開することまでは指定されていない。
つまり、公開したいものは順々にpubに指定しなければいけない。

自分の親モジュールの中にある関数に関してはsuper::を使うことでアクセスできる。
ディレクトリ操作における../みたいなもの。

構造体は各要素ごとにアクセスできるかできないかを指定することができる。
非公開時は何も書かない。公開するときは宣言時にpubをつける。

非公開のフィールドにアクセスしようとするとコンパイル時にエラーを出してくれる。
error[E0616]: field `seasonal_fruit` of struct `Breakfast` is private
  --> lib.rs:56:10
   |
56 |     meal.seasonal_fruit = String::from("blueberries");
   |          ^^^^^^^^^^^^^^ private field

error: aborting due to previous error

For more information about this error, try `rustc --explain E0616`.


一方で、enumを公開するとその中身は全て公開される。
pub enum Appetizer{
    Soup,
    Salad,
}
この例ではAppetizer::SoupもAppetizer::Saladにもアクセスできる。


useを使うことで読み込んだモジュールまでのパスを省略して書くことができるようになる。

use crate::front_of_house::hosting;
とすると、
hosting::add_to_waitlist();
みたいなところまで簡略化できる。

useには相対パスを使うこともでき、
use self::front_of_house::hosting;

みたいな感じで書ける。

関数までのパスを通すのは非推奨。なぜかと言うと関数のみになってしまい、ローカルで宣言した関数なのか持ち込んだ関数なのかが不明瞭になってしまう。
親のモジュールが明示されていたほうが読む人にとって優しい。

一方で、構造体やenumその他の要素をuseで持ち込むときはフルパスを書くのが慣例的。こっちはあんまり理由はなくてみんながそれでやってただけ。
また、同じ名前の２つの要素をuseで持ち込むのは許されないので、それらの親モジュールをuseでスコープに持ち込み、見分けられるようにする。

同じ名前をスコープに持ち込む解決方法のもう一つとしてはasを使ってエイリアスを指定してリネームすればよい。
use std::fmt::Result;
use std::io::Result as IoResult;
みたいな感じ。

pub useを使うことで、外部のコードが読み込んでいるモジュールを活用できるようになる。

標準ライブラリ(std)も自分のパッケージの外部にあるクレートになっている。
stdはRustに同梱されているのでcargo.tomlにstdを含むように変更する必要はないが、その要素をスコープに持ち込むためにはuseを使って参照する必要がある。
例えばHashMapを持ち込むには
use std::collections::HashMap;
で読み込む。

ネストしたパスを使うことで同じモジュールで定義された複数の要素を使える。
use std::{cmp::Ordering,io};
みたいな感じ。

use std::io;
use std::io::Write;

これらを一行で書きたいときはselfを使える。

use std::io::{self,Write};

パスに定義されているすべての公開要素をスコープに持ち込みたいときはglob演算子*をそのパスの後ろにつなげて書くことでできる。
use std::collections::*;

これでstd::collectionsのすべての公開要素を現在のスコープに持ち込むことができる。
とはいえ、どの名前がスコープ内にあり、プログラムで使われている名前がどこで定義されたのかわかりづらくなる。


mod front_of_houseの後にブロックではなくセミコロンを使うと、Rustにモジュールの中身をモジュールと同じ名前をした別のファイルから読み込むように命令する。

そして、それに対応するようにモジュールのファイルはモジュールの宣言のみにすれば、モジュールツリーとディレクトリ構成が一致するように作ることができる。
front_of_house::hosting::add_to_waitlist()
は
front_of_house/hosting.rs
のようにできる。


RustにおけるベクタはVec<T>である。ベクタはメモリ上に値を隣り合わせに並べる単独のデータ構造に2つ以上の値を保持させてくれる。
ベクタには同じ型の値しか保持できないので、使い分け。
ベクタの生成にはVec::new関数を呼ぶ。

let v:Vec<i32> = Vec::new();

ベクタに対して何も値を挿入していないため、型注釈が必要。
vec!というマクロを使うことで与えた値を保持する新しいベクタ型を生成できる。

let v = vec![1,2,3];

ベクタを生成してから要素を追加するにはpushメソッドを使用する。
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);

他の構造体と同じで、ベクタもスコープを抜ければ開放される。
ベクタがドロップされると、その中身もドロップされる。保持されていた整数値が片付けられる。

ベクタに保持された値を参照する方法は2つある。
ちなみに明瞭性のために型を注釈しているが、別に書かなくてもよい。

let v = vec![1,2,3,4,5];

let third: &i32 = &v[2];
let third: Option<&i32> = v.get(2);

この2つの記法にはそれぞれに利点がある。
[]によって配列外参照しようとするとプログラムがパニックするので、クラッシュさせたいときに最適。
getによって配列外参照をするとNoneを返す。人間に添え字を入力してもらう場合などは、こちらを使ったほうがパニックにならないのでありがたい。

mutであるベクタの要素への不変参照を得ているときは終端に要素を追加しようとしてもコンパイルエラーが起こる。
可変参照と不変参照は同時に存在させられないというルール。

なぜ最初の要素への参照がベクタの終端への変更を気にかける必要があるかというと、新規要素をベクタの終端に追加すると、
ベクタが現在存在する位置に隣り合って要素を入れるだけの領域がなかったときに、メモリの新規確保をして古い要素を新しいスペースにコピーする。
そのとき、最初の要素への参照は開放されたメモリを指すことになるので、借用規則によりそのような場面に陥らないように回避される。

ベクタの走査に関してはforループを使う。
let v = vec![1,2,3];
for i in &v{
    println!("{}",i);
}
可変なループは
for i in &mut v{
    *i += 50;
}

enumを使うことで、ベクタに異なる型を保持することができる。
これはあくまでベクタの保持する型は列挙子型となっているため。

文字列とはRustでは一種類しか存在せず、文字列スライスのstrで、借用された形態である&strで利用される。
これは別の場所に格納されたUTF-8エンコードされた文字列データへの参照。
文字列リテラルはプログラムのバイナリ出力に格納されるので、文字列スライスになる。

String型はRustの標準ライブラリで提供される。伸長可能、可変、所有権のあるUTF-8エンコードされた文字列型。

文字列の生成はnew関数。
let mut s = String::new();

let data = "initial contents";
let s = data.to_string();
let s = "initial contents".to_string();

to_stringメソッドを使用して、String型に変換できる。
このメソッドはDisplayトレイトを実装する型なら何でも使用できる。

また、String::from("initial contents");
とすることで、文字列リテラルからStringを生成することができる。

文字列はUTF-8エンコードされているので、アラビア文字とか韓国語とかロシア語とか全部有効なStringの値。

let mut s = String::from("foo");
s.push_str("bar");

みたいな感じで、push_strメソッドで文字列スライスを追記することでStringを伸ばすことができる。

push_strメソッドは必ずしも引数の所有権を得なくていいので、文字列スライスを取る。
これは所有権を取らないということを意味している。

pushメソッドは一文字を引数として取り、Stringに追加する。

2つのすでにある文字列を組み合わせるときには
let s1 = String::from("Hello ");
let s2 = String::from("world!");
let s3 = s1 + &s2 

最後の行の操作で、s1はムーブされ、今後使えなくなる。
これは+演算子を使用したときに呼ばれるメソッドのシグニチャは
fn add(self,s: &str) -> String{}
だからである。

&s2を使う時、コンパイラが&String引数を&strに型強制してくれる。
addメソッド呼び出しの際、コンパイラは参照外し型強制というものを使用する。
ここでは&s2を&s2[...]に変えるものと考えることができる。
addはs引数の所有権を奪わないので、この処理後もs2が有効なStringになる。

複数の文字列を連結するときはちょっと扱いにくくなる。
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;

これは正直わかりにくいので、出力のために足しているだけならばformat!マクロを利用すれば良い
let s = format!("{}-{}-{}",s1,s2,s3);

こちらのほうが読みやすく、引数の所有権を奪わない。

Stringの添字にアクセスするのはエラーが出る。
let s1 = String::from("Hello");
let h = s1[0];

Rustの文字列は添字アクセスをサポートしていない。
なぜかというと、例えばただのアルファベット文字列なら、lenはその文字数分を返す。
let len = String::from("hola").len(); //4
しかし、
let len = String::from("Здравствуйте").len(); //24
になる。これはUnicodeスカラー値が2バイトの領域を取るため。
このように、Unicodeでは文字列の取る領域が文字によって変化するため、添字アクセスでバイト値を返す操作は適切ではない。
2バイト文字の一文字目だけの分のコードが帰ってきても使用できないため。

文字列のスライスは行えるが、境界はきちんと人間側で指定してあげないといけない。
let hello = "Здравствуйте";

let s = &hello[0..4];
これに対してsはЗдになるが、
let s = &hello[0..1];
は文字の境界ではないのでプログラムがクラッシュする。

また、文字列を走査するためにはcharsメソッドを使えば良い。

for c in "नमस्ते".chars() {
    println!("{}", c);
}

上のコードは下のような出力結果を出す。
न
म
स
्
त
े

また、bytesメソッドは各バイトをそのまま返すので、使える時があるかもしれない。
このときはマルチバイト文字も切れ目を無視して返されるので注意。


HashMap<K,V>はK型のキーとV型の値の対応関係を保持する。これをハッシュ関数を介して行う。

使用する際には
use std::collections::HashMap;
let mut scores = HashMap::new();

scores.insert(String::from("Blue"),10);
scores.insert(String::from("White"),50);

HashMapはベクタやStringに比べて使用頻度が低いため、標準ライブラリのコレクション部分からuseする必要がある。
ベクタと同様に、ハッシュマップはデータをヒープに保持する。
このハッシュマップではStringをキーにi32を保持する。また、キーも値も全て同じ型でなければならない。

別の作り方としてはタプルのベクタに対してcollectメソッドを使用する方法。

use std::collections::HashMap;

let teams  = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();


zipメソッドによってタプルのベクタを作り上げることができ、それをcollectメソッドによってタプルのベクタをハッシュマップに変換している。
ここではHashMap<_,_>という型注釈が必要になる。collectメソッドはいろいろなデータ構造にまとめ上げることができてしまうので、どの型に変換したいかは自分で指定する必要がある。
しかし、キーと値の型に関してはアンダースコアで、コンパイラはベクタのデータ型に基づいてハッシュマップが含む型を推論することができる。

i32などのCopyトレイトを実装する型については値はハッシュマップにコピーされる。
insertを呼び出して渡した変数がハッシュマップにムーブされた後は、その変数を使用できなくなる。

error[E0382]: borrow of moved value: `field_name`
  --> main.rs:13:15
   |
4  | let field_name = String::from("Favorite color");
   |     ---------- move occurs because `field_name` has type `String`, which does not implement the `Copy` trait
...
8  | map.insert(field_name, field_value);
   |            ---------- value moved here
...
13 | println!("{}",field_name);
   |               ^^^^^^^^^^ value borrowed here after move

実際に使ってみるとこのようなエラーが出る。
値への参照をハッシュマップに挿入したら値はハッシュマップにムーブされない。
参照が指している値は、最低でもハッシュマップが有効な間は有効でなければならない。

ハッシュマップの値にアクセスするためにはキーをgetメソッドに提供する。

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);

こんな感じで使い、getはOption<&V>を返す。ここでの結果はSome(&10)となる。
キーに対応する値がハッシュマップに存在しなければgetはNoneを返す。

走査するためにはforループを活用できる。

for (key,value) in &scores{
    println!("{}: {}",key,value);
}

これは各ペアを任意の順番で出力する。

ハッシュマップの更新にはいくつか方法がある。
値を上書きするためにはinsertで同じ名前のキーで別の値を入れれば良い。最後にinsertした値になる。

キーに値がなかったときのみ値を挿入することも可能で、entryと呼ばれる特別なAPIを通して行われる。

scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

or_insertのメソッドに渡した値が、キーが存在しなかったときに代入する値になっている。


let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);

この出力は
{"hello": 1, "wonderful": 1, "world": 2}
のようになる。

or_insertは実際はこのキーに対する値への可変参照を返す。つまりその可変参照を変数に保持することにより、
参照外しをして変更ができる。これがキーの値を古い値に基づいて更新する方法。


Rustでは大きく2種類のエラーが存在する。回復可能なエラーと回復不能なエラー。
Rustには例外が存在しない代わりに、回復可能なエラーにはResult<T,E>値があり、
プログラムが回復不能なエラーに遭遇した際には実行を中止するpanic!マクロがある。

panic!マクロが実行されると、プログラムは失敗のメッセージを表示し、スタックを巻き戻し掃除して終了する。
標準ではパニックが発生するとプログラムは巻き戻しを始める。スタックを遡って各関数のデータを片付ける。
この片付けを行わず、即座に異常終了させるためにはCargo.tomlファイルの
[profile.release]
panic = 'abort'
とすればリリースモード時に異常終了することができる。

panic!によって表示されるエラーメッセージにパニックを起こしたソースコードと行数が含まれている。

RUST_BACKTRACE環境変数を0以外の値にセットするとバックトレースがどんどん深く表示されるようになる。


例えばファイルを開こうとしたときにstd::fs::File::open()を使うと、返り値はResult。
これにより
let f:u32 = File::open("hello.txt");
がエラーになる。返り値はあくまでResult<T,E>である。
ここでは成功値の型はstd::fs::Fileで、エラー値で使用されている型はstd::io::Error

File::openには成功したか失敗したかを知らせる方法とファイルハンドル。またはエラー情報を与える方法が必要。
この情報こそがResultのenumが伝達するもの。

File::openが成功した場合、変数fの値はファイルハンドルを含むOkインスタンスになる。
失敗した場合には、発生したエラーの種類に関する情報をより多く含むErrインスタンスがfの値になる。


use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            // ファイルを開く際に問題がありました
            panic!("There was a problem opening the file: {:?}", error)
        },
    };
}

こんな感じでファイルを開けたかどうかで分岐させる。

エラーによって動作を変えたいときにはmatch文で別々に分岐させることができる。

use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(ref error) if error.kind() == ErrorKind::NotFound => {
            match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => {
                    panic!(
                        //ファイルを作成しようとしましたが、問題がありました
                        "Tried to create file but there was a problem: {:?}",
                        e
                    )
                },
            }
        },
        Err(error) => {
            panic!(
                "There was a problem opening the file: {:?}",
                error
            )
        },
    };
}

この場合はファイルが見つからないエラーならファイルを生成して、それ以外のエラーならpanicさせている。

if error.kind() == ErrorKind::Notfoundという条件式はマッチガードと呼ばれる。
アームのパターンを更に洗練するmatchアーム上のおまけの条件式。
refを使っているのはerrorがガード条件式にムーブされないように必須。
refを使用して＆の代わりに使っている理由はあとで詳しく解説するらしい。

matachはいささか冗長なのでショートカットがある。
let f = File::open("hello.txt").unwrap();

を使用すると、Result値がOk列挙子ならunwrapはOkの中身を返す。
ResultがErr列挙子ならunwrapはpanic!マクロを呼んでくれる。

また、expectというunwrapに似たメソッドが存在するが、これはpanic!のエラーメッセージも選択させてくれる。
unwrapの代わりにexpectを使用してエラーメッセージを提供するとパニックの原因をたどりやすくなる。

let f = File::open("hello.txt").expect("Failed to open hello.txt");

これはコード内のどこでエラーメッセージが出力されたのかより見つけやすくなる。
unwrapは全て同じメッセージを出力するのでわかりにくい可能性がある。


Result<T,E>を返す関数を作るときには
let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
こんな感じで早期リターンして返り値をエラーで埋めることができる。
こういったエラーの移譲はRustでは非常に一般的なので?演算子によってしやすくしている。

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}

これはさっきのものとほぼ同じことをしている。
Resultの値がOkならOkの中身がこの式から返ってきて、値がErrならreturnキーワードを使ったかのように関数全体からErrの中身が返ってくる。

match式と?演算子の違いは、?を使ったエラー値は標準ライブラリのFromトレイトで定義され、エラーの方を別のものに変換するfrom関数を通ること。
これは受け取ったエラー型を現在の関数の戻り値型に変換するため。
各エラー型がfrom関数を実装して返り値のエラー型への変換を定義している限り、?演算子が返還の面倒を自動的に見てくれる。

let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)

こんな感じで、?演算子の後のメソッド呼び出しを連結することでコードを短くすることができる。

ちなみに、?演算子はResultの返り値をもつ関数でしか使用が許可されないとコンパイルエラーが出るので、main関数で使ったりはできない。
Resultを返さない関数ではmatchかResultのメソッドのどれかを使う必要がある。


回復する可能性のある手段のある無しに関わらずpanic!を呼ぶことはできるが、呼び出す側のコードの立場に立つとこの場面は回復不能だという決定を下すことになる。
Result値を返すようにすると、決断を下すのではなく、呼び出し側に選択肢を与えることになる。
呼び出し側は場面に合わせて回復を試みたり、このErr値は回復不能だと断定して、panic!を呼び出すこともできる。

プロトタイプコードを作っているときにはunwrapやexpectメソッドは、エラーの処理法を決定する準備ができる前の段階では便利。

コンパイラよりもプログラマがより情報を持っている場合。つまり、ハードコードされた文字列からインスタンスを生成したりするとき、
プログラマは合法なインスタンスであることを理解できるが、コンパイラはErrが返ってくる可能性を考えた処理を強要してくる。
こういったときにはunwrapを使用すると便利。ユーザーの入力起源でインスタンスを生成し、失敗する可能性がある場合はResultを使って処理したほうが良い。

コードが悪い状態に陥る可能性があるときにパニックさせるのは推奨。
悪い状態とは、何らかの前提・保証・契約・不変性が破られたことを言い、無効な値、矛盾する値、行方不明な値がコードに渡されること。
さらに以下のいずれか一つ以上の状態であること。
・悪い状態がときに起こるとは予想されない時
・この時点以降、この悪い状態にないことを頼りにコードが書かれている時
・使用している方にこの情報をコード化する良い手段がない時

誰かが自分のコードを呼び出して筋の通らない値を渡してきたら最善の選択肢はpanic!させること。
また、自分の制御下にない外部コードを呼び出し、終生飼養のない無効な状態を返すときはpanic!はしばしば適切。

とはいえ大抵の場合はpanic!呼び出しをするよりもResultを返すほうがより適切。
失敗が予想される可能性であることを示唆できるため。

コードが値に対して処理を行う場合、コードはまず値が合法であることを確認し、値が合法でなければパニックするべき。
これは安全性上の理由によるものが大きく、不正なデータの処理を試みるとコードを脆弱性に晒す可能性がある。
関数には呼び出し側がコードを修正する必要があるため、パニックするのが適正。

不正な値を使用時にいちいちチェックするのではなく、新しく型を作ってしまい、new関数内で与えられた値の範囲チェックやパニックを実装しておく。
そうすることによりチェックを全関数で行う必要がなくなり、安全に使える。

Rustのエラー処理機能は、プログラマがより頑健なコードを書く手助けをするように設計されている。
panic!マクロはプログラムが処理できない状態にあり、無効だったり不正な値で処理を継続するのではなく、プロセスに処理を中止するよう指示することを通知する。
Result列挙子はRustの型システムを使用して、コードが回復可能な方法で処理が失敗するかもしれないことを示唆する。
Resultを使用すると、呼び出し側のコードに成功や失敗をする可能性を処理する必要があることも教えてくれる。