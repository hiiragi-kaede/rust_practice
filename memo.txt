println!はRustのマクロを呼び出す。
！を使うと、普通の関数ではなくマクロを読んでいるということを知っておこう。

cargoはnpmみたいな感じでライブラリとかのバージョン管理を行ってくれる。
cargo new <project_name> --bin
とかで新規プロジェクトを作れる。
cargo check でエラーをチェックし、実際ビルドが必要なときには
cargo build →./target/debug/<project_name>
もしくは　cargo run
でできる。

cargo build --releaseを使うと最適化を行ってコンパイルできる。
このときはコンパイルに時間がかかるようになるため回数は少ないほうが良い。

cargo.lockによって破壊的アップデートがあったとしても、明示的にアップグレードしなければ再現可能なビルドを構成してくれる。


不変変数と定数がどちらも存在している。
不変変数はletで、定数はconstで宣言する。
定数は必ず型を必ず注釈しなければならず、グローバルスコープを含めてどこのスコープでも定義できる。
定数は定数式にしかセットできず、関数呼び出し結果や実行時に評価される値にはセットできない。
Rustの定数の命名規則としては全て大文字で、アンダースコアで単語区切りすること。

可変変数はシャドーイングにより定義し直すことで型や値を変更できるが、mutによって型を変更することは許されていない。

Rustにおける値は全て何らかのデータ型になっている。Rustは静的型付き言語であるので、コンパイル時にすべての変数の型が判明している必要がある。
コンパイラは値と使用方法に基づいて型を推論してくれる。parseメソッドのように変換先が複数の型が可能な場合には、変数に型注釈をつけなければいけない。

整数型は符号付きと符号無しで、8bitの大きさの変数としてi8とu8のような感じで存在する。8~64bitまである。
整数リテラルは他言語と同じ感じ。アンダーバーを見た目の区切り記号として使うことができる。
10進数→98222
16進数→0xff
8進数→0o77
2進数→0b1111_0000
バイト→b'A'

浮動小数点型はf32とf64があるが、基準型はf64になる。
let x =2.0; ならf64
let y: f32 = 3.0; ならf32になる。
論理値型はtrueとfalseの2つしかない。
文字型としてchar型があるが、こちらはダブルクオーテーションを使う文字列に対して、シングルクォートで指定される。

複合型としてタプルなどがある。
タプルはlet tup = (500,6.4,1)
(型注釈をわざわざつけると　let tup: (i32, f54, u8) = (500,6.4,1))
タプルはすべての型を揃える必要はない。

タプルから個々の値を取り出すにはパターンマッチングを使用して分解することができる。
let (x,y,z) = (500,6.4,1)
println!("value:{}",y);
みたいな感じ。

タプルの要素へのアクセスはパターンマッチング以外にも添え字アクセスができる。
とはいえ添字アクセスにはピリオドを使うことでタプルの要素に直接アクセスすることができる。
x.0とかx.1など。
ちなみに添字は0始まり。

配列は固定長なので、一度宣言されたらサイズを伸ばすことも縮めることもできない。
let a = [1,2,3,4,5]
角括弧内にカンマ区切りリストとして記述する。
配列はヒープよりもスタックにデータのメモリを確保したいときに有効。
配列とベクタ型があるが、大抵の場合はベクタ型を使うべき。ベクタはサイズを伸縮させることができる。まあC++のやつと同じということみたい。
こっちのアクセスはx[0]とかx[1]みたいないつものアクセス方法。
配列外参照をすると実行時エラーが起こり、言語はパニックする。
パニックとはプログラムがエラーで終了したことを表すRust用語。