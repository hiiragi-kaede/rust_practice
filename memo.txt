println!はRustのマクロを呼び出す。
！を使うと、普通の関数ではなくマクロを読んでいるということを知っておこう。

cargoはnpmみたいな感じでライブラリとかのバージョン管理を行ってくれる。
cargo new <project_name> --bin
とかで新規プロジェクトを作れる。
cargo check でエラーをチェックし、実際ビルドが必要なときには
cargo build →./target/debug/<project_name>
もしくは　cargo run
でできる。

cargo build --releaseを使うと最適化を行ってコンパイルできる。
このときはコンパイルに時間がかかるようになるため回数は少ないほうが良い。

cargo.lockによって破壊的アップデートがあったとしても、明示的にアップグレードしなければ再現可能なビルドを構成してくれる。


不変変数と定数がどちらも存在している。
不変変数はletで、定数はconstで宣言する。
定数は必ず型を必ず注釈しなければならず、グローバルスコープを含めてどこのスコープでも定義できる。
定数は定数式にしかセットできず、関数呼び出し結果や実行時に評価される値にはセットできない。
Rustの定数の命名規則としては全て大文字で、アンダースコアで単語区切りすること。

可変変数はシャドーイングにより定義し直すことで型や値を変更できるが、mutによって型を変更することは許されていない。

Rustにおける値は全て何らかのデータ型になっている。Rustは静的型付き言語であるので、コンパイル時にすべての変数の型が判明している必要がある。
コンパイラは値と使用方法に基づいて型を推論してくれる。parseメソッドのように変換先が複数の型が可能な場合には、変数に型注釈をつけなければいけない。

整数型は符号付きと符号無しで、8bitの大きさの変数としてi8とu8のような感じで存在する。8~64bitまである。
整数リテラルは他言語と同じ感じ。アンダーバーを見た目の区切り記号として使うことができる。
10進数→98222
16進数→0xff
8進数→0o77
2進数→0b1111_0000
バイト→b'A'

浮動小数点型はf32とf64があるが、基準型はf64になる。
let x =2.0; ならf64
let y: f32 = 3.0; ならf32になる。
論理値型はtrueとfalseの2つしかない。
文字型としてchar型があるが、こちらはダブルクオーテーションを使う文字列に対して、シングルクォートで指定される。

複合型としてタプルなどがある。
タプルはlet tup = (500,6.4,1)
(型注釈をわざわざつけると　let tup: (i32, f54, u8) = (500,6.4,1))
タプルはすべての型を揃える必要はない。

タプルから個々の値を取り出すにはパターンマッチングを使用して分解することができる。
let (x,y,z) = (500,6.4,1)
println!("value:{}",y);
みたいな感じ。

タプルの要素へのアクセスはパターンマッチング以外にも添え字アクセスができる。
とはいえ添字アクセスにはピリオドを使うことでタプルの要素に直接アクセスすることができる。
x.0とかx.1など。
ちなみに添字は0始まり。

配列は固定長なので、一度宣言されたらサイズを伸ばすことも縮めることもできない。
let a = [1,2,3,4,5]
角括弧内にカンマ区切りリストとして記述する。
配列はヒープよりもスタックにデータのメモリを確保したいときに有効。
配列とベクタ型があるが、大抵の場合はベクタ型を使うべき。ベクタはサイズを伸縮させることができる。まあC++のやつと同じということみたい。
こっちのアクセスはx[0]とかx[1]みたいないつものアクセス方法。
配列外参照をすると実行時エラーが起こり、言語はパニックする。
パニックとはプログラムがエラーで終了したことを表すRust用語。

Rustの関数はfn <関数名>(){}　みたいな感じで宣言できる。
Rustの関数と変数の命名規則はスネークケースを使うのが慣例。
コンパイラは関数がどこで定義されているかを気にせず、どこかで定義されているかどうかのみを気にする。

関数の引数を追加するときには、各仮引数の型を宣言しなければならない。
fn sample_func(x: i32,y: i64)
みたいな感じで複数の引数に対してはコンマで区切って指定する。

Rustではx=y=6みたいな文法は許されていない。代入文は値を返さないためこうなる。
let y ={
    let ret = sample_func()
    ret*2 + 1
};
みたいな感じでブロックで代入できる。この場合最後の行は文末にセミコロンがついていないことに注意。

戻り値のある関数は他の言語と違った記法になっている。
fn five() -> i32{
    5
}
fn main(){
    let x = five();
}
みたいな感じ。戻り値に名前をつけはしないが矢印のあとに型を書いて宣言する。
returnキーワードで値を指定することもできるが、多くの関数は最後の式を暗黙的に返す。

Rustにおけるコメントは全部//。複数行にまたがる場合は全部に//をつける。

if文はGoみたいなかんじ。条件式にカッコを付けなくても大丈夫。
条件式はbool型でないといけないことにも注意。
else ifが増えすぎると見にくくなってしまうので、多すぎる場合はmatchと呼ばれる文法を使用すること推奨。

let文内でif文を使うこともでき、
let num = if condition{
    5
}else{
    4
};
みたいに使う。
注意点としては、この使い方をするときはifとelseで代入する値の型を同じにしないとコンパイルエラーが出る。

loop{}
で簡単に無限ループを作れる。この場合ctrl+c使わないと中断させられないので注意（もしくはbreakするかか？）

while cnt!=0{
    func();
    cnt = cnt-1;
}
みたいな感じでいつものようにwhileループを作れる。

let a = [10,20,30,40,50];

for ele in a.iter(){
    println!("the number is {}",ele);
}
みたいな感じでforループを作成できる。

for number in (1..4).rev(){
    println!("{}",number);
}
でカウントダウンを作れる

コンパイル時にサイズが分かるものはスタックに。
コンパイル時にサイズがわからなかったり、サイズが可変のデータはヒープに置かれる。
スタックはデータを探す段階が存在しないため、ヒープのデータアクセスよりも高速。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Rustの所有権の規則は以下の通り。
・Rustの各値は、所有者と呼ばれる変数と対応している。
・いかなる時も所有者は一つである。
・所有者がスコープから外れたら、値は破棄される。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

文字列リテラルは不変であり、入力を受け付けて保持したいときなどには使えない。
そのためにString型がある。
String型はヒープにメモリを確保するので、コンパイル時にはサイズが不明なテキストも保持することができる。

let s = String::from("hello");

こういった文字列は可変化することができる。
let mut s = String::from("hello");
s.push_str(",world!");
println!("{}",s);


文字列リテラルの場合、中身はコンパイル時に判明しているので、テキストは最終的なバイナリファイルに直接ハードコードされる。
そのため、文字列リテラルは高速で効率的になる。
一方で、サイズが既知であったり、不変であるからこの強みが活かせるのであり、使いにくい場面もある。

C++などではメモリを要求する場合はallocateとfreeを完璧に一対一に対応させなければならないが、Rustは違う。
メモリを所有している変数がスコープを抜けたときにメモリを自動的に返還する。
スコープを抜ける際にdropと呼ばれる関数を自動的に呼ぶ。

let s1 = String::from("hello");
let s2 = s1;

これは保存先のヒープへのポインタをs2が保持する。
つまり、スタックにあるポインタ・長さ・許容量をコピーし、ポインタが指すヒープ上のデータはコピーしない。
これらがそのままスコープを抜けるとs1とs2を開放しようとするが、これは二重開放になってしまう。
そのため、Rustではこのようなことをしたときにs2にs1を代入したときにs1を無効化する。
つまりs2にs1をムーブする。s2だけが有効になっているので、s2を開放して安全に開放される。

ムーブでなく深いコピーをしたいときにはcloneメソッドを活用する。
let s1 = String::from("hello");
let s2 = s1.clone();
これならs1もs2もスコープ内で使用でき、スコープを抜けたときに2つとも開放される。

整数のようなコンパイル時に既知のサイズを持つ型は、ムーブではなくコピーされる。
大抵は無効にする必要性が皆無なため。
これはCopyトレイトと呼ばれる注釈がついている。（トレイトはよくわかっていないのであってるか不明）

Copyとなる型は以下のようなもの（全部ではない）
・u32などの整数型。
・bool型
・f64などの浮動小数点型。
・文字列であるchar
・Copyの型だけを含むタプル。


Copyトレイトでない型を関数に渡すと、所有権が渡され元の変数は使えなくなる。
元の変数を使った時点でコンパイルエラーが出るのでまあ安心か。
値を返す関数によっても所有権が移動する。

関数に渡すときにいちいち所有権が渡されるのがめんどくさいときは参照で渡すことができる。
&s1　で渡して　s: &String　みたいな感じで受け取る

参照で渡したものを変更することはできない。変数が標準で不変なのと同様に参照も不変。
これを変更したいときには一捻りを加えるだけでOK。

change(&mut s);
fn change(str: &mut String){}

一つ重要な点として、特定のスコープでは、同じデータに対して一つしか可変な参照を持てない。

let mut s = String::from("hello");

let r1 = &s; // 問題なし
let r2 = &s; // 問題なし
let r3 = &mut s; // 大問題！

このように、可変と不変な参照を組み合わせることに関しても厳しく取り締まられている。
不変な参照をしている間は可変な参照をすることができない。しかし、読み込むだけである不変参照を複数作ることには制約は存在しない。

Stringの値を要素ごとに見るためにはas_bytesメソッドを使うことでStringオブジェクトをバイト配列に変換している。
とはいえこのやり方ではStringオブジェクトと添字が一致して更新されないので（求めてからStringをクリアできてしまう）、困る。

fn main() {
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
}
このようにRustではスライスはこのように書く。
[0:5]はPythonとかGoで、Rustは[0..5]
これはStringの一部への参照を作成している。他言語と同じく後ろの添字までは含まない（[0..5]は0~4までのサイズ5）
Pythonと同じく、自明なら添字を省略できる
[0..2] = [..2]
[3..len] = [3..]
[0..len] = [..]

文字列スライスを意味する方は&strになる。
文字列スライスがあるとき、不変な参照が存在している。つまり、不変参照が存在している間可変な参照は得られないので、安全に使うことができる。

文字列リテラルの型は&strになっている。そのため文字列は不変になっている。
また、Stringの値と&strを両方扱える関数にするためには、引数の型を&strにするとよい。
文字列リテラルを渡すときにはそのままでよく、Stringを渡すときには&my_string[..]にすれば問題なく動かすことができる。