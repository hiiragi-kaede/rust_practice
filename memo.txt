println!はRustのマクロを呼び出す。
！を使うと、普通の関数ではなくマクロを読んでいるということを知っておこう。

cargoはnpmみたいな感じでライブラリとかのバージョン管理を行ってくれる。
cargo new <project_name> --bin
とかで新規プロジェクトを作れる。
cargo check でエラーをチェックし、実際ビルドが必要なときには
cargo build →./target/debug/<project_name>
もしくは　cargo run
でできる。

cargo build --releaseを使うと最適化を行ってコンパイルできる。
このときはコンパイルに時間がかかるようになるため回数は少ないほうが良い。

cargo.lockによって破壊的アップデートがあったとしても、明示的にアップグレードしなければ再現可能なビルドを構成してくれる。


不変変数と定数がどちらも存在している。
不変変数はletで、定数はconstで宣言する。
定数は必ず型を必ず注釈しなければならず、グローバルスコープを含めてどこのスコープでも定義できる。
定数は定数式にしかセットできず、関数呼び出し結果や実行時に評価される値にはセットできない。
Rustの定数の命名規則としては全て大文字で、アンダースコアで単語区切りすること。

可変変数はシャドーイングにより定義し直すことで型や値を変更できるが、mutによって型を変更することは許されていない。

Rustにおける値は全て何らかのデータ型になっている。Rustは静的型付き言語であるので、コンパイル時にすべての変数の型が判明している必要がある。
コンパイラは値と使用方法に基づいて型を推論してくれる。parseメソッドのように変換先が複数の型が可能な場合には、変数に型注釈をつけなければいけない。

整数型は符号付きと符号無しで、8bitの大きさの変数としてi8とu8のような感じで存在する。8~64bitまである。
整数リテラルは他言語と同じ感じ。アンダーバーを見た目の区切り記号として使うことができる。
10進数→98222
16進数→0xff
8進数→0o77
2進数→0b1111_0000
バイト→b'A'

浮動小数点型はf32とf64があるが、基準型はf64になる。
let x =2.0; ならf64
let y: f32 = 3.0; ならf32になる。
論理値型はtrueとfalseの2つしかない。
文字型としてchar型があるが、こちらはダブルクオーテーションを使う文字列に対して、シングルクォートで指定される。

複合型としてタプルなどがある。
タプルはlet tup = (500,6.4,1)
(型注釈をわざわざつけると　let tup: (i32, f54, u8) = (500,6.4,1))
タプルはすべての型を揃える必要はない。

タプルから個々の値を取り出すにはパターンマッチングを使用して分解することができる。
let (x,y,z) = (500,6.4,1)
println!("value:{}",y);
みたいな感じ。

タプルの要素へのアクセスはパターンマッチング以外にも添え字アクセスができる。
とはいえ添字アクセスにはピリオドを使うことでタプルの要素に直接アクセスすることができる。
x.0とかx.1など。
ちなみに添字は0始まり。

配列は固定長なので、一度宣言されたらサイズを伸ばすことも縮めることもできない。
let a = [1,2,3,4,5]
角括弧内にカンマ区切りリストとして記述する。
配列はヒープよりもスタックにデータのメモリを確保したいときに有効。
配列とベクタ型があるが、大抵の場合はベクタ型を使うべき。ベクタはサイズを伸縮させることができる。まあC++のやつと同じということみたい。
こっちのアクセスはx[0]とかx[1]みたいないつものアクセス方法。
配列外参照をすると実行時エラーが起こり、言語はパニックする。
パニックとはプログラムがエラーで終了したことを表すRust用語。

Rustの関数はfn <関数名>(){}　みたいな感じで宣言できる。
Rustの関数と変数の命名規則はスネークケースを使うのが慣例。
コンパイラは関数がどこで定義されているかを気にせず、どこかで定義されているかどうかのみを気にする。

関数の引数を追加するときには、各仮引数の型を宣言しなければならない。
fn sample_func(x: i32,y: i64)
みたいな感じで複数の引数に対してはコンマで区切って指定する。

Rustではx=y=6みたいな文法は許されていない。代入文は値を返さないためこうなる。
let y ={
    let ret = sample_func()
    ret*2 + 1
};
みたいな感じでブロックで代入できる。この場合最後の行は文末にセミコロンがついていないことに注意。

戻り値のある関数は他の言語と違った記法になっている。
fn five() -> i32{
    5
}
fn main(){
    let x = five();
}
みたいな感じ。戻り値に名前をつけはしないが矢印のあとに型を書いて宣言する。
returnキーワードで値を指定することもできるが、多くの関数は最後の式を暗黙的に返す。

Rustにおけるコメントは全部//。複数行にまたがる場合は全部に//をつける。

if文はGoみたいなかんじ。条件式にカッコを付けなくても大丈夫。
条件式はbool型でないといけないことにも注意。
else ifが増えすぎると見にくくなってしまうので、多すぎる場合はmatchと呼ばれる文法を使用すること推奨。

let文内でif文を使うこともでき、
let num = if condition{
    5
}else{
    4
};
みたいに使う。
注意点としては、この使い方をするときはifとelseで代入する値の型を同じにしないとコンパイルエラーが出る。

loop{}
で簡単に無限ループを作れる。この場合ctrl+c使わないと中断させられないので注意（もしくはbreakするかか？）

while cnt!=0{
    func();
    cnt = cnt-1;
}
みたいな感じでいつものようにwhileループを作れる。

let a = [10,20,30,40,50];

for ele in a.iter(){
    println!("the number is {}",ele);
}
みたいな感じでforループを作成できる。

for number in (1..4).rev(){
    println!("{}",number);
}
でカウントダウンを作れる