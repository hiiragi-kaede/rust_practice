19.2 高度なトレイトから

関連型はトレイトのメソッド定義がシグニチャでプレースホルダーの型を使用できるように、トレイトと型のプレースホルダーを結びつける。
トレイトを実装するものがこの特定の実装で型の位置に使用される具体的な型を指定する。
そうすることで、なんらかの型を使用する取り柄とをトレイトを実装するまでその型が一体何であるかを知ることなく定義することが出来る。

とはいえこの内容はあまり使わない内容。

関連型があるトレイトの一例として、標準ライブラリが提供するIteratorトレイトが挙げられる。
その関連型はItemと名付けられ、Iteratorトレイトを実装している型が走査している値の型の代役を務める。

pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}

Iteratorトレイトの定義は以上の様になっていると以前述べた。

型Itemはプレースホルダー型で、nextメソッドの定義は型Option<Self::Item>の値を返すことを示している。
Iteratorトレイトを実装するものは、Itemの具体的な型を指定し、nextメソッドはその具体的な型の値を含むOptionを返す。

関連型はジェネリクスにより扱う方を指定せずに関数を定義できるという点でジェネリクスに似ているように思われる。
そこでなぜ関連型を使うかについて、ジェネリクスと比較していく。

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
    }
}

pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}

例えば上が関連型、下がジェネリクスで実装してみたもの。
違いとしては、下のようにジェネリクスを使用すると、各実装で型を注釈しなければならないこと。
Iterator<String> for Counterや他のどんな型にも実装することが出来るので、
CounterのIteratorの実装が複数できる。つまり、トレイトにジェネリックな引数があると、
毎回ジェネリックな型引数の具体的な型を変更してある型に対して複数回実装できるということ。
Counterに対してnextメソッドを使用する際に、どのIteratorの実装を使用したいのか型注釈を付けなければならなくなる。

関連型ならば同じ型に対してトレイトを複数回実装できないので、型を注釈する必要がなくなる。
関連型を使う場合ではItemの型は一回しか選択できない。
一つしかimpl Iterator for Counterがないため。Counterにnextくぉ呼び出すたびに、u32値のイテレータが欲しいと指定しなくてもよくなる。


ジェネリックな型引数を使用する際、ジェネリックな型に対して既定の具体的な型を指定できる。
これにより、既定の型が動くのならトレイトを実装する側が具体的な型を指定する必要を排除する。
ジェネリックな型に既定の型を指定する記法は、ジェネリックな型を宣言する際に
<PlaceholderType=ConcreteType>

このテクニックを有用にしてくれる場面として、演算子オーバーロードが挙げられる。
Rustでは独自の演算子を作ったり、任意の演算子をオーバーロードすることはできない。
しかし、演算子に紐付いたトレイトを実装することで、std::opsに列挙された処理と対応するトレイトをオーバーロードできる。
例えばAddトレイトを実装することにより+演算子をオーバーロードすることが出来る。

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}

addメソッドは２つのPointインスタンスのx値と２つのPointインスタンスのy値を足す。
Addトレイトにはaddメソッドから返却される型を決定するOutputという関連型がある。

このコードの既定のジェネリック型はAddトレイト内にあり、以下のようになっている。
trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}

RHS=Selfの部分が、デフォルト型引数と呼ばれる記法。
RHSというジェネリックな型引数(right hand side:右辺の省略形)が、addメソッドのrhs引数の型を定義している。
Addトレイトを実装する際にRHSの具体的な型を指定しなければ、RHSの型は標準でSelfになり、これはAddを実装している型になる。
今回は２つのPointインスンタンスを足したかったので、RHSの既定を使用した。既定を使用するのではなく、RHSの型をカスタマイズしたくなる実装例に目を向けてみよう。

異なる単位で値を保持する構造体、MillimetersとMetersが２つあり、ミリメートルの値をメートルの値に足し、Addの実装に変換を正しくしてもらう。

use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}

MilimetersにMetersを足すので、Selfという既定を使う代わりにimpl Add<Meters>を指定して、RHS型引数の値をセットしている。

主に２通りの方法でデフォルト型引数を使用する。
・既存のコードを破壊せずに型を拡張する
・ほとんどのユーザーは必要としない特定の場合でカスタマイズを可能にする

標準ライブラリのAddトレイトは２つ目の目的の例。通常２つの似た型を足すが、Addトレイトはそれ以上にカスタマイズする能力を提供する。
Addトレイト定義でデフォルト型引数を使用することは、殆どの場合追加の引数を指定しなくてもよいことを意味する。
つまりトレイトを使いやすくして、ちょっとだけ実装の定型コードが必要なくなる。

最初の目的は２つ目に似ているが、逆のことを意味している。
既存のトレイトに型引数を追加したいなら、既定を与えて既存の実装コードを破壊せずにトレイトの機能を拡張できる。