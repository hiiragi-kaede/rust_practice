19.2 高度なトレイトから

関連型はトレイトのメソッド定義がシグニチャでプレースホルダーの型を使用できるように、トレイトと型のプレースホルダーを結びつける。
トレイトを実装するものがこの特定の実装で型の位置に使用される具体的な型を指定する。
そうすることで、なんらかの型を使用する取り柄とをトレイトを実装するまでその型が一体何であるかを知ることなく定義することが出来る。

とはいえこの内容はあまり使わない内容。

関連型があるトレイトの一例として、標準ライブラリが提供するIteratorトレイトが挙げられる。
その関連型はItemと名付けられ、Iteratorトレイトを実装している型が走査している値の型の代役を務める。

pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}

Iteratorトレイトの定義は以上の様になっていると以前述べた。

型Itemはプレースホルダー型で、nextメソッドの定義は型Option<Self::Item>の値を返すことを示している。
Iteratorトレイトを実装するものは、Itemの具体的な型を指定し、nextメソッドはその具体的な型の値を含むOptionを返す。

関連型はジェネリクスにより扱う方を指定せずに関数を定義できるという点でジェネリクスに似ているように思われる。
そこでなぜ関連型を使うかについて、ジェネリクスと比較していく。

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
    }
}

pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}

例えば上が関連型、下がジェネリクスで実装してみたもの。
違いとしては、下のようにジェネリクスを使用すると、各実装で型を注釈しなければならないこと。
Iterator<String> for Counterや他のどんな型にも実装することが出来るので、
CounterのIteratorの実装が複数できる。つまり、トレイトにジェネリックな引数があると、
毎回ジェネリックな型引数の具体的な型を変更してある型に対して複数回実装できるということ。
Counterに対してnextメソッドを使用する際に、どのIteratorの実装を使用したいのか型注釈を付けなければならなくなる。

関連型ならば同じ型に対してトレイトを複数回実装できないので、型を注釈する必要がなくなる。
関連型を使う場合ではItemの型は一回しか選択できない。
一つしかimpl Iterator for Counterがないため。Counterにnextくぉ呼び出すたびに、u32値のイテレータが欲しいと指定しなくてもよくなる。


ジェネリックな型引数を使用する際、ジェネリックな型に対して既定の具体的な型を指定できる。
これにより、既定の型が動くのならトレイトを実装する側が具体的な型を指定する必要を排除する。
ジェネリックな型に既定の型を指定する記法は、ジェネリックな型を宣言する際に
<PlaceholderType=ConcreteType>

このテクニックを有用にしてくれる場面として、演算子オーバーロードが挙げられる。
Rustでは独自の演算子を作ったり、任意の演算子をオーバーロードすることはできない。
しかし、演算子に紐付いたトレイトを実装することで、std::opsに列挙された処理と対応するトレイトをオーバーロードできる。
例えばAddトレイトを実装することにより+演算子をオーバーロードすることが出来る。

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}

addメソッドは２つのPointインスタンスのx値と２つのPointインスタンスのy値を足す。
Addトレイトにはaddメソッドから返却される型を決定するOutputという関連型がある。

このコードの既定のジェネリック型はAddトレイト内にあり、以下のようになっている。
trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}

RHS=Selfの部分が、デフォルト型引数と呼ばれる記法。
RHSというジェネリックな型引数(right hand side:右辺の省略形)が、addメソッドのrhs引数の型を定義している。
Addトレイトを実装する際にRHSの具体的な型を指定しなければ、RHSの型は標準でSelfになり、これはAddを実装している型になる。
今回は２つのPointインスンタンスを足したかったので、RHSの既定を使用した。既定を使用するのではなく、RHSの型をカスタマイズしたくなる実装例に目を向けてみよう。

異なる単位で値を保持する構造体、MillimetersとMetersが２つあり、ミリメートルの値をメートルの値に足し、Addの実装に変換を正しくしてもらう。

use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}

MilimetersにMetersを足すので、Selfという既定を使う代わりにimpl Add<Meters>を指定して、RHS型引数の値をセットしている。

主に２通りの方法でデフォルト型引数を使用する。
・既存のコードを破壊せずに型を拡張する
・ほとんどのユーザーは必要としない特定の場合でカスタマイズを可能にする

標準ライブラリのAddトレイトは２つ目の目的の例。通常２つの似た型を足すが、Addトレイトはそれ以上にカスタマイズする能力を提供する。
Addトレイト定義でデフォルト型引数を使用することは、殆どの場合追加の引数を指定しなくてもよいことを意味する。
つまりトレイトを使いやすくして、ちょっとだけ実装の定型コードが必要なくなる。

最初の目的は２つ目に似ているが、逆のことを意味している。
既存のトレイトに型引数を追加したいなら、既定を与えて既存の実装コードを破壊せずにトレイトの機能を拡張できる。


Rustにおいて、別のトレイトのメソッドと同じ名前のメソッドがトレイトにあったり、両方のトレイトを1つの型に実装することを妨げる機能はなにもない。
トレイトのメソッドと同じ名前のメソッドを直接型に実装することも可能。

同じ名前のメソッドを呼ぶ際、コンパイラにどれを使用したいのか教える必要がある。
両方ともflyというメソッドがある2つのトレイト、PilotとWizardを定義した以下のコードを例に上げる。

trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        // キャプテンのお言葉
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        // 上がれ！
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        // *激しく腕を振る*
        println!("*waving arms furiously*");
    }
}


fn main() {
    let person = Human;
    person.fly();
}
この場合、Humanのインスタンスに対してflyの呼び出しを行うとコンパイラは型に直接実装されたメソッドを標準で呼び出す。
この実行結果は"waving arms"になる。

fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
その他のトレイトのメソッドを呼び出すためにはより明示的な記法を使用して、どのflyメソッドを意図しているか指定する必要がある。

flyメソッドはself引数を取るので、1つのトレイトを両方実装する型が2つあれば、コンパイラにはselfの型に基づいてどのトレイトの実装を使うべきかわかる。
しかし、トレイトの一部になる関連関数にはself引数がない。
同じスコープの2つの型がそのトレイトを実装する場合、フルパス記法を使用しない限りどの型を意図しているかコンパイラは推論できない。
下の例ではAnimalトレイトには、関連関数baby_name、構造体DogのAnimalの実装、Dogに直接定義された関連関数baby_nameがある。

trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        // スポット(Wikipediaによると、飼い主の事故死後もその人の帰りを待つ忠犬の名前の模様)
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        // 子犬
        String::from("puppy")
    }
}

fn main() {
    // 赤ちゃん犬は{}と呼ばれる
    println!("A baby dog is called a {}", Dog::baby_name());
}

このコードでは出力は"A baby dog is called a Spot"と出力される。これはDogでの実装。
実際はAnimalのDogへの実装を使用したい。

fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}

だからといってこのように修正すると、Animal::baby_nameはメソッドではなく関連関数であり、self引数が無いので、
どのAnimal::baby_nameがほしいのかコンパイラには推論できず、コンパイルエラーが出る。

fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}

フルパス記法で書くことによりこの問題を解決することができ、それは上のコードのようになる。
この出力は"A baby dog is called a puppy"にきちんとなってくれる。

一般的にフルパス記法は以下のように定義されている。
<Type as Trait>::function(receiver_if_method, next_arg, ...);

関連関数ではreceiverがなく、他の引数のリストがあるだけ。
関数やメソッドを呼び出す箇所全部でフルパス記法を使用することも出来るだろうが、プログラムの他の情報からコンパイラが推論できる
この記法のどの部分も省略することが許容されている。同じ名前を使用する実装が複数あり、どの実装を呼び出したいのかコンパイラが特定する際に
助けが必要な場合だけにこの冗長な記法を使用する必要がある。


・スーパートレイトを使用して別のトレイト内であるトレイトの機能を必要とする
時としてあるトレイトに別のトレイトの機能を使用させる必要がある可能性がある。
このとき、依存するトレイトも実装されることを信用する必要がある。
信用するトレイトは実装しているトレイトのスーパートレイトになる。

例えばアスタリスクをフレームに値を出力するoutline_printメソッドがあるOutlinePrintトレイトを作りたくなったとする。
この場合Displayを実装し(x,y)という結果になるPoint構造体が与えられ、(1,3)のPointインスタンスに対して、outline_printを呼び出すと以下のような出力になる。

**********
*        *
* (1, 3) *
*        *
**********

outline_printの実装ではDisplayトレイトの機能を使用したいために、Displayも実装する型に対してだけOutlinePrintが動くと指定し、
OutlinePrintが必要とする機能を提供する必要がある。トレイト定義でOutlinePrint: Displayと指定することによってそのようにできる。
このテクニックはトレイトにトレイト境界を追加することに似ている。

use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

OutlinePrintはDisplayトレイトを必要とすると指定したので、Displayを実装するどんな型にも自動的に実装されるto_string関数を利用できる。
トレイト名の後にコロンとDisplayトレイトを追加せずにto_stringを使おうとしたら、現在のスコープで型&Selfにto_stringというメソッドが存在しないというエラーが出る。

struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}

例えばこのようにDisplayを実装しないPoint構造体にOutlinePrintを実装しようとすると以下のようなエラーが出る。

error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --> src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`


解決のためにPointにDisplayを実装することによって、エラーを消すことが出来る。
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}


・ニュータイプパターンを使用して外部の型に外部のトレイトを実装する
トレイトか型がクレートにローカルな限り、型にトレイトを実装できると以前に述べた。
ニュータイプパターンを使用してこの制限を回避することができ、タプル構造体に新しい型を作成することになる。
タプル構造体は1つのフィールドを持ち、トレイトを実装したい型の薄いラッパになる。
そしてラッパの型はクレートにローカルなのでトレイトをラッパに実装できる。

このニュータイプという用語はHaskellプログラミング言語に端を発している。
このパターンを使用するのに実行時のパフォーマンスの犠牲を払う必要はなく、ラッパ型はコンパイル時に省かれる。

例としてVec<T>にDisplayを実装したいとする。DisplayトレイトもVec<T>型もクレートの外で定義されているので、
直接それを行うことはオーファンルールにより妨げられる。
Vec<T>のインスタンスを保持するWrapper構造体を作成でき、WrapperにDisplayを実装することにより問題を解決できる。


use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}


Displayの実装はself.0で中身のVec<T>にアクセスしている。Wrapperはタプル構造体で、
Vec<T>がタプルの添字0の要素だから。それからWrapperに対してDisplay型の機能を使用できる。

このテクニックを使用する欠点はWrapperが新しい型なので、保持している値のメソッドがないこと。self.0に移譲して、
WrapperをVec<T>と全く同様に扱えるようにWrapperに直接Vec<T>の全てのメソッドを実装しなければならない。
内部の型が持つ全てのメソッドを新しい型に持たせたいのなら、DerefトレイトをWrapperに実装して、内部の値を返すことが解決策の1つとして挙げられる。
内部の型のメソッド全部をWrapper型に持たせたくないのなら、本当に欲しいメソッドだけを手動で実装しなければならなくなる。