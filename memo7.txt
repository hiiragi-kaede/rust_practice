20,マルチスレッドのウェブサーバ構築から

TCPは情報がとあるサーバから別のサーバへどう到達するかの詳細を記述するものの、
その情報がなんなのかは指定しない、より低レベルのプロトコル。HTTPはリクエストとレスポンスの中身を定義することでTCPの上に成り立っている。
技術的にはHTTPを他のプロトコルとともに使用することが出来るが、大抵の場合はHTTPはTCPの上にデータを送信する。
TCPとHTTPのリクエストとレスポンスの生のバイトを取り扱う。


TcpListener::bind("127.0.0.1:7878").unwrap();

std::net::TcpListenerを使うことにより、アドレス127.0.0.1:7878でTCP接続をリッスン出来る。
アドレス内でコロンの前の区域は自分のコンピュータを表すIPアドレスで、7878はポート。
このポートを選んだ理由として、HTTPは通常このポートで受け入れられることと7878は電話でrustと入力されるから。

この筋書きでのbind関数は新しいTcpListenerインスタンスを返すという点でnew関数のような働きをする。
この関数がbindと呼ばれている理由は、ネットワークにおいてリッスンすべきポートに接続することは、
ポートに束縛することとして知られている。

bind関数はResult<T,E>を返し、束縛が失敗することもあることを示している。
例えばポート80に接続するには管理者権限が必要なので、管理者にならずにポート80に接続しようとしたらうまくいかない。
また、自分のプログラムを2つ同時に立ち上げて2つのプログラムが同じポートをリッスンしたら、束縛は機能しない。
学習目的のためだけに基本的なサーバを記述しているので、この類のエラーを扱う心配をせず、unwrapを使用してエラーが発生したらプログラムを停止する。

TcpListenerのincomingメソッドは一連のストリームを与えるイテレータを返す。具体的には型TcpStreamのストリーム。
単独のストリームがクライアント・サーバ間の開かれた接続を表す。
せず奥は、クライアントがサーバに接続し、サーバがレスポンスを生成し、サーバが接続を閉じるというリクエストとレスポンス全体の過程の名前。
そのため、TcpStreamは自身を読み取ってクライアントが送信したことを確認し、それからレスポンスをストリームに記述させてくれる。
総括すると、このforループでは各接続を順番に処理し、自分たちが扱えるように一連のストリームを生成している。

まず最初にストリームはunwrapを呼び出して、ストリームにエラーが有った場合はプログラムを停止することから始めている。
エラーがなければプログラムはメッセージを出力する。
クライアントがサーバーに接続する際にincomingメソッドからエラーを受け取る可能性がある理由は、実際には接続を走査していないから。
代わりに接続の試行を走査している。接続は多くの理由で失敗する可能性があり、そのうちの多くはOS特有。
例を上げれば多くのOSにはサポートできる同時に開いた接続数に上限がある。開かれた接続の一部が閉じられるまでその上限数を超えた接続の試行はエラーになる。

現在の実装ではサーバがデータを返してこないのでブラウザではエラーが出るが、メッセージは出ているので接続ができていることを確認できる。
一回のブラウザリクエストで複数のメッセージが出力されるのは、ブラウザがサーバに何度も接続を試みているという可能性があるが、理由は定かではない。

streamがスコープを抜け、ループの最後でドロップされると、接続はdrop実装の一部として閉じられる。
ブラウザは再試行することで閉じられた接続を扱うことがある。問題が一時的なものである可能性があるため。
重要な要素はTCP接続へのハンドルを得ることに成功したということ。