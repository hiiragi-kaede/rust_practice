13 関数型言語の機能：イテレータとクロージャから

Rustのクロージャは変数に保存したり、引数として他の関数に渡すことの出来る匿名関数。
ある場所でクロージャを生成し、それから別の文脈でクロージャを呼び出して評価することが出来る。
関数と異なり、呼び出されたスコープの値をクロージャはキャプチャすることが出来る。

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    // ゆっくり計算します
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}

たとえばこんなシンプル関数を定義して呼び出すときに、関数名を長々と呼ぶのは面倒くさい。
関数呼び出しの結果を保存するのではなく、そのクロージャを変数に保存できる。

let expensive_closure = |num|{
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};

このクロージャの記法はsmalltalkやRubyのクロージャ定義と類似している。
２つ以上引数があるときは|param1, param2|のようにカンマで区切って定義する。

例えば重い計算をする関数の呼び出し結果を変数に保存する時、その計算結果を使用しない条件分岐があったとしても呼び出すのは無駄。
そうした状況の時、クロージャで定義をしておけば本当に必要な場面でのみ重い計算をする関数を呼び出すことができる。

fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

クロージャは型注釈をつけることも出来るが、短い処理をするだけのクロージャの目的にはそぐわないので省略される事が多い。


let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);

こんな感じで引数に与えられた値をそのまま返すだけのクロージャを定義した時、引数に渡すものの型を変えて２度呼び出すとエラーが起こる。
String値でexample_closureを呼び出した時点でコンパイラは引数と返り値をStringと推論するようになる。
そうすると同じクロージャを別の型で使用しようとすると、型エラーが出る。

重い処理をクロージャに閉じ込める解決方法の別方法として、クロージャやクロージャの呼び出し結果の値を保持する構造体を作ることが出来る。
結果の値が必要な場合のみにクロージャを実行し、その結果の値をキャッシュすることで、残りのコードは再利用する責任を負わなくて済む。
このパターンはメモ化、もしくは遅延評価として知られている。

クロージャを保持する構造体を作成するためにクロージャの型を指定する必要がある。
構造体定義は各フィールドの型を把握しておく必要があるため。
各クロージャインスタンスには独自の匿名の型が存在している。

Fnトレイトは標準ライブラリで用意されている。全てのクロージャは以下のいずれかのトレイトを実装する。
・Fn
・FnMut
・FnOnce

Fnトレイト境界にいくつかの型を追加することで、このトレイト境界に合致するクロージャが持つべき引数と戻り値の型を示す。

struct Cacher<T>
    where T:Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

Cacher構造体はジェネリックな型Tのcalculationフィールドを持つ。Tのトレイト境界はFnトレイトを使うことでクロージャで指定している。
calculationフィールドに保存したいクロージャは全てu32の引数を取り、u32の返り値を持つクロージャでなければならない。

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}

このようにメソッドを定義することにより、Cacherを使用するコードがクロージャの結果を求めてくると、
その時点でCacherはクロージャを実行し、その結果をvalueフィールドのSome列挙子に保存する。
既に結果を求めたことがあればクロージャを再実行するのではなく、Some列挙子に保存された結果を返す。

呼び出し元のコードにフィールドを直接変えてもらうようにするのは不適当なため、これらのフィールドは非公開にしている。

let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

さっきの内容をクロージャを持つ構造体で作り直すとこの様になる。

クロージャの結果を利用する際は
expensive_result.value(intensity)
のようにする。

例えば複数回使用して、多様な引数をクロージャに与える場合、最初に呼び出した結果がSomeに保存されてしまうせいでうまく行かないこともある。
この場合はハッシュマップを保持するようにCacherを改変すれば良い。ハッシュマップのキーを引数にし、その関数の実行結果をバリューに保存しておく。


クロージャには関数にはない追加の能力がある。自分が定義されたスコープの変数にアクセスすることが出来る。
let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));

これは問題なく動くが、クロージャでなく関数で定義するとxにアクセスできないというエラーが出る。

ここで先程出てきた複数のトレイトの違いが出てくる。

・FnOnceは、クロージャの環境として知られている内包されたスコープからキャプチャした変数を消費します。 
キャプチャした変数を消費するために、定義された際にクロージャはこれらの変数の所有権を奪い、 自身にムーブするのです。
名前のうち、Onceの部分は、 このクロージャは同じ変数の所有権を2回以上奪うことができないという事実を表しているので、1回しか呼ぶことができないのです。
・FnMutは、可変で値を借用するので、環境を変更することができます。
・Fnは、環境から値を不変で借用します

環境でクロージャが使用している値の所有権を奪うことをクロージャに矯正したいなら、引数リストの前にmoveキーワードを使用できる。
このテクニックは新しいスレッドにデータが所有されるように、クロージャを新しいスレッドに渡して、データをムーブする際に有用。

fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    // ここでは、xを使用できません: {:?}
    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}

Fnトレイトのどれかを指定する殆どの場合、Fnから始めるとコンパイラがクロージャ本体内で起こっていることを解析し、
FnMutやFnOnceが必要な場合教えてくれる。