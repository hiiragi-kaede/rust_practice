13 関数型言語の機能：イテレータとクロージャから

Rustのクロージャは変数に保存したり、引数として他の関数に渡すことの出来る匿名関数。
ある場所でクロージャを生成し、それから別の文脈でクロージャを呼び出して評価することが出来る。
関数と異なり、呼び出されたスコープの値をクロージャはキャプチャすることが出来る。

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    // ゆっくり計算します
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}

たとえばこんなシンプル関数を定義して呼び出すときに、関数名を長々と呼ぶのは面倒くさい。
関数呼び出しの結果を保存するのではなく、そのクロージャを変数に保存できる。

let expensive_closure = |num|{
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};

このクロージャの記法はsmalltalkやRubyのクロージャ定義と類似している。
２つ以上引数があるときは|param1, param2|のようにカンマで区切って定義する。

例えば重い計算をする関数の呼び出し結果を変数に保存する時、その計算結果を使用しない条件分岐があったとしても呼び出すのは無駄。
そうした状況の時、クロージャで定義をしておけば本当に必要な場面でのみ重い計算をする関数を呼び出すことができる。

fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

クロージャは型注釈をつけることも出来るが、短い処理をするだけのクロージャの目的にはそぐわないので省略される事が多い。


let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);

こんな感じで引数に与えられた値をそのまま返すだけのクロージャを定義した時、引数に渡すものの型を変えて２度呼び出すとエラーが起こる。
String値でexample_closureを呼び出した時点でコンパイラは引数と返り値をStringと推論するようになる。
そうすると同じクロージャを別の型で使用しようとすると、型エラーが出る。

重い処理をクロージャに閉じ込める解決方法の別方法として、クロージャやクロージャの呼び出し結果の値を保持する構造体を作ることが出来る。
結果の値が必要な場合のみにクロージャを実行し、その結果の値をキャッシュすることで、残りのコードは再利用する責任を負わなくて済む。
このパターンはメモ化、もしくは遅延評価として知られている。

クロージャを保持する構造体を作成するためにクロージャの型を指定する必要がある。
構造体定義は各フィールドの型を把握しておく必要があるため。
各クロージャインスタンスには独自の匿名の型が存在している。

Fnトレイトは標準ライブラリで用意されている。全てのクロージャは以下のいずれかのトレイトを実装する。
・Fn
・FnMut
・FnOnce

Fnトレイト境界にいくつかの型を追加することで、このトレイト境界に合致するクロージャが持つべき引数と戻り値の型を示す。

struct Cacher<T>
    where T:Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

Cacher構造体はジェネリックな型Tのcalculationフィールドを持つ。Tのトレイト境界はFnトレイトを使うことでクロージャで指定している。
calculationフィールドに保存したいクロージャは全てu32の引数を取り、u32の返り値を持つクロージャでなければならない。

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}

このようにメソッドを定義することにより、Cacherを使用するコードがクロージャの結果を求めてくると、
その時点でCacherはクロージャを実行し、その結果をvalueフィールドのSome列挙子に保存する。
既に結果を求めたことがあればクロージャを再実行するのではなく、Some列挙子に保存された結果を返す。

呼び出し元のコードにフィールドを直接変えてもらうようにするのは不適当なため、これらのフィールドは非公開にしている。

let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

さっきの内容をクロージャを持つ構造体で作り直すとこの様になる。

クロージャの結果を利用する際は
expensive_result.value(intensity)
のようにする。

例えば複数回使用して、多様な引数をクロージャに与える場合、最初に呼び出した結果がSomeに保存されてしまうせいでうまく行かないこともある。
この場合はハッシュマップを保持するようにCacherを改変すれば良い。ハッシュマップのキーを引数にし、その関数の実行結果をバリューに保存しておく。


クロージャには関数にはない追加の能力がある。自分が定義されたスコープの変数にアクセスすることが出来る。
let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));

これは問題なく動くが、クロージャでなく関数で定義するとxにアクセスできないというエラーが出る。

ここで先程出てきた複数のトレイトの違いが出てくる。

・FnOnceは、クロージャの環境として知られている内包されたスコープからキャプチャした変数を消費します。 
キャプチャした変数を消費するために、定義された際にクロージャはこれらの変数の所有権を奪い、 自身にムーブするのです。
名前のうち、Onceの部分は、 このクロージャは同じ変数の所有権を2回以上奪うことができないという事実を表しているので、1回しか呼ぶことができないのです。
・FnMutは、可変で値を借用するので、環境を変更することができます。
・Fnは、環境から値を不変で借用します

環境でクロージャが使用している値の所有権を奪うことをクロージャに矯正したいなら、引数リストの前にmoveキーワードを使用できる。
このテクニックは新しいスレッドにデータが所有されるように、クロージャを新しいスレッドに渡して、データをムーブする際に有用。

fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    // ここでは、xを使用できません: {:?}
    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}

Fnトレイトのどれかを指定する殆どの場合、Fnから始めるとコンパイラがクロージャ本体内で起こっていることを解析し、
FnMutやFnOnceが必要な場合教えてくれる。


イテレータはただ単に生成するだけでは何も意味がない。
一番単純な使用方法はforループに活用すること。

let v1 = vec![1,2,3];

for val in v1.iter(){
    println!("Got: {}",val);
}

添字アクセスをすることによってエラーを生み出してしまうことがありうるので、このような拡張for的な使い方が一番単純。

全てのイテレータは標準ライブラリで定義されているIteratorというトレイトを実装している。
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // デフォルト実装のあるメソッドは省略
    // methods with default implementations elided
}

このように定義されている。type ItemによりIteratorトレイトを実装するためにはItem型も定義する必要があり、
Item型がnextメソッドの返り値の型に使われている。

nextメソッドは一度にSomeに包まれたイテレータの一要素を返し、繰り返しが終わったらNoneを返すことだけを要求している。
nextメソッドは直接呼び出すことも出来るが、let mut v1_iter = v1.iter()というように可変にする必要があることに注意。
forループで使う際にはループがv1_iterの所有権を奪って可変にしているため、ループで使う際には可変にする必要はない。

nextを呼び出すメソッドは消費アダプタ(consuming adaptors)と呼ばれる。
呼び出しがイテレータを使い込むので、そういったメソッドを使った後に渡したイテレータに所有権は無いために、
メソッド呼び出し後にイテレータを使うことはできなくなる。
一例としてsumメソッドなど。

let total: i32 = v1_iter.sum();

のような感じ。このあとv1_iterは使うことができなくなる。


Iteratorトレイトに定義された他のメソッドとしてイテレータアダプタとして知られている。
イテレータを別の種類のイテレータに替えてくれる。とはいえ、消費アダプタメソッドのどれかを呼び出し、イテレータアダプタの呼び出しから結果を得る必要がある。

イテレータアダプタメソッドのmapでは各要素に対して呼び出すクロージャを取り、新しいイテレータを作成する。

let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
//v2 = [2, 3, 4]

ここで使っているVec<_>に関しては、代入するために渡しているもので型が明示的に示されているので省略できるというもの。
とりあえず適当に使ってもだめならコンパイラがエラー出してくれると思うので使えそうな機能。


#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from("sneaker") },
        Shoe { size: 13, style: String::from("sandal") },
        Shoe { size: 10, style: String::from("boot") },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from("sneaker") },
            Shoe { size: 10, style: String::from("boot") },
        ]
    );
}
こんな形でfileterメソッドはイテレータの各要素をとり、論理値を返すクロージャを取る。
最終的にcollectを呼び出す必要があることを忘れずに。


struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

独自のイテレータを作成する際にはnextメソッドさえ定義していれば何でも良い。
例えば1~5までの値を順に返すイテレータを作成する例が上にある。


#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
例えばこんな複雑な形でイテレータを使うことも出来る。
1~5を返すイテレータを2つ生成し、一つは最初の1つの要素をスキップし、くっつける。
それらの組同士をかけ合わせ、3で割り切れるものだけを残して合計を求めている。
zipは(5,None)に対しては組を生成しないので、今回生成されるのは4組のみであることに注意。

単純にループで書くのと、イテレータのアダプタメソッドを使ってfilterしたりするのは、パフォーマンス的には大して変わりない。
これは高度に抽象化されているのにも関わらず、低レベルのコードを自身で書いているかのように、ほぼ同じコードにコンパイルされる。
コンパイラは繰り返しの回数が固定ならループを展開し、ループ制御コードのオーバーヘッドを除去し、ループの繰り返しごとに同じコードを生成する最適化。