13 関数型言語の機能：イテレータとクロージャから

Rustのクロージャは変数に保存したり、引数として他の関数に渡すことの出来る匿名関数。
ある場所でクロージャを生成し、それから別の文脈でクロージャを呼び出して評価することが出来る。
関数と異なり、呼び出されたスコープの値をクロージャはキャプチャすることが出来る。

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    // ゆっくり計算します
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}

たとえばこんなシンプル関数を定義して呼び出すときに、関数名を長々と呼ぶのは面倒くさい。
関数呼び出しの結果を保存するのではなく、そのクロージャを変数に保存できる。

let expensive_closure = |num|{
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};

このクロージャの記法はsmalltalkやRubyのクロージャ定義と類似している。
２つ以上引数があるときは|param1, param2|のようにカンマで区切って定義する。

例えば重い計算をする関数の呼び出し結果を変数に保存する時、その計算結果を使用しない条件分岐があったとしても呼び出すのは無駄。
そうした状況の時、クロージャで定義をしておけば本当に必要な場面でのみ重い計算をする関数を呼び出すことができる。

fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

クロージャは型注釈をつけることも出来るが、短い処理をするだけのクロージャの目的にはそぐわないので省略される事が多い。


let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);

こんな感じで引数に与えられた値をそのまま返すだけのクロージャを定義した時、引数に渡すものの型を変えて２度呼び出すとエラーが起こる。
String値でexample_closureを呼び出した時点でコンパイラは引数と返り値をStringと推論するようになる。
そうすると同じクロージャを別の型で使用しようとすると、型エラーが出る。

重い処理をクロージャに閉じ込める解決方法の別方法として、クロージャやクロージャの呼び出し結果の値を保持する構造体を作ることが出来る。
結果の値が必要な場合のみにクロージャを実行し、その結果の値をキャッシュすることで、残りのコードは再利用する責任を負わなくて済む。
このパターンはメモ化、もしくは遅延評価として知られている。

クロージャを保持する構造体を作成するためにクロージャの型を指定する必要がある。
構造体定義は各フィールドの型を把握しておく必要があるため。
各クロージャインスタンスには独自の匿名の型が存在している。

Fnトレイトは標準ライブラリで用意されている。全てのクロージャは以下のいずれかのトレイトを実装する。
・Fn
・FnMut
・FnOnce

Fnトレイト境界にいくつかの型を追加することで、このトレイト境界に合致するクロージャが持つべき引数と戻り値の型を示す。

struct Cacher<T>
    where T:Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

Cacher構造体はジェネリックな型Tのcalculationフィールドを持つ。Tのトレイト境界はFnトレイトを使うことでクロージャで指定している。
calculationフィールドに保存したいクロージャは全てu32の引数を取り、u32の返り値を持つクロージャでなければならない。

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}

このようにメソッドを定義することにより、Cacherを使用するコードがクロージャの結果を求めてくると、
その時点でCacherはクロージャを実行し、その結果をvalueフィールドのSome列挙子に保存する。
既に結果を求めたことがあればクロージャを再実行するのではなく、Some列挙子に保存された結果を返す。

呼び出し元のコードにフィールドを直接変えてもらうようにするのは不適当なため、これらのフィールドは非公開にしている。

let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

さっきの内容をクロージャを持つ構造体で作り直すとこの様になる。

クロージャの結果を利用する際は
expensive_result.value(intensity)
のようにする。

例えば複数回使用して、多様な引数をクロージャに与える場合、最初に呼び出した結果がSomeに保存されてしまうせいでうまく行かないこともある。
この場合はハッシュマップを保持するようにCacherを改変すれば良い。ハッシュマップのキーを引数にし、その関数の実行結果をバリューに保存しておく。


クロージャには関数にはない追加の能力がある。自分が定義されたスコープの変数にアクセスすることが出来る。
let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));

これは問題なく動くが、クロージャでなく関数で定義するとxにアクセスできないというエラーが出る。

ここで先程出てきた複数のトレイトの違いが出てくる。

・FnOnceは、クロージャの環境として知られている内包されたスコープからキャプチャした変数を消費します。 
キャプチャした変数を消費するために、定義された際にクロージャはこれらの変数の所有権を奪い、 自身にムーブするのです。
名前のうち、Onceの部分は、 このクロージャは同じ変数の所有権を2回以上奪うことができないという事実を表しているので、1回しか呼ぶことができないのです。
・FnMutは、可変で値を借用するので、環境を変更することができます。
・Fnは、環境から値を不変で借用します

環境でクロージャが使用している値の所有権を奪うことをクロージャに矯正したいなら、引数リストの前にmoveキーワードを使用できる。
このテクニックは新しいスレッドにデータが所有されるように、クロージャを新しいスレッドに渡して、データをムーブする際に有用。

fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    // ここでは、xを使用できません: {:?}
    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}

Fnトレイトのどれかを指定する殆どの場合、Fnから始めるとコンパイラがクロージャ本体内で起こっていることを解析し、
FnMutやFnOnceが必要な場合教えてくれる。


イテレータはただ単に生成するだけでは何も意味がない。
一番単純な使用方法はforループに活用すること。

let v1 = vec![1,2,3];

for val in v1.iter(){
    println!("Got: {}",val);
}

添字アクセスをすることによってエラーを生み出してしまうことがありうるので、このような拡張for的な使い方が一番単純。

全てのイテレータは標準ライブラリで定義されているIteratorというトレイトを実装している。
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // デフォルト実装のあるメソッドは省略
    // methods with default implementations elided
}

このように定義されている。type ItemによりIteratorトレイトを実装するためにはItem型も定義する必要があり、
Item型がnextメソッドの返り値の型に使われている。

nextメソッドは一度にSomeに包まれたイテレータの一要素を返し、繰り返しが終わったらNoneを返すことだけを要求している。
nextメソッドは直接呼び出すことも出来るが、let mut v1_iter = v1.iter()というように可変にする必要があることに注意。
forループで使う際にはループがv1_iterの所有権を奪って可変にしているため、ループで使う際には可変にする必要はない。

nextを呼び出すメソッドは消費アダプタ(consuming adaptors)と呼ばれる。
呼び出しがイテレータを使い込むので、そういったメソッドを使った後に渡したイテレータに所有権は無いために、
メソッド呼び出し後にイテレータを使うことはできなくなる。
一例としてsumメソッドなど。

let total: i32 = v1_iter.sum();

のような感じ。このあとv1_iterは使うことができなくなる。


Iteratorトレイトに定義された他のメソッドとしてイテレータアダプタとして知られている。
イテレータを別の種類のイテレータに替えてくれる。とはいえ、消費アダプタメソッドのどれかを呼び出し、イテレータアダプタの呼び出しから結果を得る必要がある。

イテレータアダプタメソッドのmapでは各要素に対して呼び出すクロージャを取り、新しいイテレータを作成する。

let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
//v2 = [2, 3, 4]

ここで使っているVec<_>に関しては、代入するために渡しているもので型が明示的に示されているので省略できるというもの。
とりあえず適当に使ってもだめならコンパイラがエラー出してくれると思うので使えそうな機能。


#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from("sneaker") },
        Shoe { size: 13, style: String::from("sandal") },
        Shoe { size: 10, style: String::from("boot") },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from("sneaker") },
            Shoe { size: 10, style: String::from("boot") },
        ]
    );
}
こんな形でfileterメソッドはイテレータの各要素をとり、論理値を返すクロージャを取る。
最終的にcollectを呼び出す必要があることを忘れずに。


struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

独自のイテレータを作成する際にはnextメソッドさえ定義していれば何でも良い。
例えば1~5までの値を順に返すイテレータを作成する例が上にある。


#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
例えばこんな複雑な形でイテレータを使うことも出来る。
1~5を返すイテレータを2つ生成し、一つは最初の1つの要素をスキップし、くっつける。
それらの組同士をかけ合わせ、3で割り切れるものだけを残して合計を求めている。
zipは(5,None)に対しては組を生成しないので、今回生成されるのは4組のみであることに注意。

単純にループで書くのと、イテレータのアダプタメソッドを使ってfilterしたりするのは、パフォーマンス的には大して変わりない。
これは高度に抽象化されているのにも関わらず、低レベルのコードを自身で書いているかのように、ほぼ同じコードにコンパイルされる。
コンパイラは繰り返しの回数が固定ならループを展開し、ループ制御コードのオーバーヘッドを除去し、ループの繰り返しごとに同じコードを生成する最適化。


cargoには2つの主なプロファイルが存在する。
devプロファイルはcargo buildコマンドを実行したときに使用される。
releaseプロファイルはcargo build --releaseコマンドを実行したときに使用される。
devプロファイルは開発中に役に立つデフォルト設定がなされていて、releaseプロファイルはリリース用の設定がなされている。

Cargo.tomlファイルに[profile.*]セクションが存在しない際に適用される各プロファイル用のデフォルト設定がCargoに存在する。
[profile.*]セクションを追加することでデフォルト設定の一部を上書きすることが出来る。
デフォルト値のopt-levelはdevは0、releaseは3

opt-levelはコンパイラがコードに適用する最適化の度合いを制御する。
最適化を多くかけるとコンパイル時間が伸びるので、devは素早く、releaseは実行を早くするためにこうなっている。


ドキュメンテーションコメントは2つではなく三連スラッシュを使用する。
また、ドキュメント用のテキスト整形のためにMarkdown記法をサポートしている。
cargo docを実行することでHTMLドキュメントを生成することが出来る。
このコマンドはコンパイラとともに配布されているrustdocツールを実行し、生成されたHTMLドキュメントをtarget/docディレクトリに配置する。

cargo doc --openを走らせることで現在のクレートのドキュメント用のHTMLを構築し、その結果をウェブブラウザで開く。

クレート筆者がよく使用するセクションとして、
#Example：使用のためのコードの例示
#Panics：関数がpanic!する可能性のある筋書き
#Errors：関数がResultを返す時、起きうるエラーの種類とそれを引き起こす条件を解説すると呼び出し側の役に立つ
#Safety：関数が呼び出すのにunsafeなら関数がunsafeな理由を説明し、関数が呼び出し元に保持していると期待する不変条件を講義するセクションがあるべき。

テストにドキュメンテーションコメントを付けた際には、ドキュメントのコード例をテストとして実行する。
ドキュメントが書かれてからコードが変更されたために動かない例が載っているのは害悪なため、
cargo testを走らせたときにDoc-testsというのが実行され、きちんとコード例が動くコードなのかを検証してくれる。

//!というdocコメントは、コメントに続く要素いドキュメンテーションを付け加えるのではなく、
コメントを含む要素にドキュメンテーションを付け加える。
典型的な使い方としてはクレートのルートファイル（大抵はsrc/lib.rs）内部や、モジュールの内部で使用して、
クレートやモジュール全体にドキュメントをつける。
特にクレートやモジュール自体の解説に有用であり、コンテナの全体の目的を説明し、クレートの使用者にクレートの体系理解の手助けをする。

クレート内に複数のモジュールがあり、その中の構造体や関数を使いたいときには、使用者側は
extern crate art;
use art::kinds::PrimaryColor;
のようにartクレートの内部構造を理解する必要が生まれてしまう。
また、docもkindsまでしか表示をしてくれず、kindsに潜ることで初めてPrimaryColorの存在を認知することが出来る。

そこで、lib.rs内でpub use文を追加して、最上位で要素を再エクスポートすることが出来る。
pub use kinds::PrimaryColor;
これをすることにより、クレートのトップページにPrimaryColorが表示されるようになり、使用者に優しくなる。
また、使用する際にも再エクスポートされたモジュールは省略記法を使えるようになるので積極的に使うべき。
extern crate art;
use art::PrimaryColor;
で済むので。

Crates.ioにクレートを公開するためにはcrates.ioのアカウントを作成し、APIトークンを取得する必要がある。
ログイン時には
cargo login <APIキー>
で実行する。当然APIキーは秘密なので共有しないように！

公開したいクレートは既に公開されているクレート名と被ってはいけない。
そのため、Cargo.tomlファイルの[package]以下の名前を編集して、名前を公開用に使う必要がある。
[package]
name="guessing_game"

独自の名前を選択していてもcargo publishはこの時点では警告とエラーが出てしまう。
クレートのライセンスなどの情報が必要になるため。

license="MIT"　自分のクレートをMITライセンスでライセンスする。
Rustコミュニティの多くの人間はMIT OR Apache-2.0のデュアルライセンスを使用することで、Rust自体と同じようにプロジェクトをライセンスする。

[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
description = "A fun game where you guess what number the computer has chosen."
              (コンピュータが選択した数字を言い当てる面白いゲーム)
license = "MIT OR Apache-2.0"

[dependencies]
例としてはこんな感じ。

公開は永久なのでクレートの公開時には特に気をつけなければならない。バージョンは絶対に上書きできず、コードも削除できない。
公開時には
cargo publish
を使う。

クレートに変更を行い、新バージョンをリリースするときにはhttp://semver.org/
に従って変更の種類に基づいて次の適切なバージョン番号を決定する。
そのあと、cargo publishを行い新バージョンをアップロードする。

あるバージョンのクレートを取り下げるには
cargo yank --vers <バージョン名>
で行うことが出来る。
cargo yank --vers <バージョン名> --undo
で取り下げを取り消すことが出来る。
これはバージョンを取り下げることにより新規プロジェクトが新しくそのバージョンに依存しだすことを防止してくれるだけ。
既存のプロジェクトは引き続きダウンロードしたりそのバージョンに依存したりし続けられる。

取り下げはコードの削除は一切しないので、秘密鍵を上げてしまったときなどには使えず、この場合は秘密鍵の再発行が正しい対応。


ライブラリクレートの肥大化が続くと複数宇野ライブラリクレートにパッケージを分割したくなる。
この場面においてCargoはワークスペースという協調して開発された関連のある複数のパッケージを管理するのに役立つ機能を提供している。

ワークスペースは同じCargo.lockと出力ディレクトリを共有する一連のパッケージ。
ワークスペースを構築する方法は複数あるが、一般的な方法としてはバイナリ1つとライブラリ2つを含むワークスペースを作る。
バイナリは主要な機能を提供するが、2つのライブラリに依存している。

Cargo.tomlファイルの[workspace]セクションに注目。
そのCargo.tomlファイルが存在するディレクトリでmembersに指定しているパスの名前のバイナリクレートを作成する。
この場合cargo buildを行うと作ったディレクトリ下ではなく、最上位にtargetディレクトリが作られる。
ワークスペースのクレートはお互いに依存し合うことを意味するので、targetディレクトリをこのように構成する。
各クレートがtargetディレクトリを持っているといちいち再コンパイルする必要ができてしまうので、一つにまとめて共有することが大事。

[dependencies]
add-one = {path = "../add-one"}
のようにバイナリクレートのadderをライブラリクレートのadd-oneに依存させられる。
Cargoはワークスペースのクレートがお互いに依存しているとは想定していないので、クレート間の依存関係について明示する必要がある。
ちなみにこれを書くのはadderのディレクトリ下のCargo.toml

ワークスペースでのディレクトリからバイナリクレートを実行するには-p引数とパッケージ名をcargo runとともに使用して、
使用したいワークスペースのパッケージを指定する必要がある。
cargo run -p adder
みたいな感じ。

randクレートを別々のクレートでそれぞれ追加すると、Cargoは両者のあるバージョンのrandに解決し、それを一つのCargo.lockに記録する。
ワークスペースの全クレートに同じ依存を使用させるということは、ワークスペースのクレートが相互に互換性を常に維持するということになる。
例えばadderの依存にrandクレートを追加したところで、add-oneの方でrandクレートを使うことはできない。
randがワークスペースのどこかで使用されていたとしても、それぞれのCargo.tomlファイルにもrandを追加しない限り、
ワークスペースの他のクレートでそれを使用することはできない。

ワークスペースのクレートを公開する際には、それぞれのクレートを個別に公開する必要がある。
cargo publishには--allフラグや-pフラグは無いので、各クレートのディレクトリに移動してcargo publishをする必要がある。


cargo installコマンドにより、バイナリクレートをローカルにインストールし、使用することが出来る。
Rustの開発者が、他人がcrates.ioに共有したツールをインストールするのに便利。
バイナリターゲットを持つパッケージのみインストールできることに注意。
バイナリターゲットとは、クレートがsrc/main.rsファイルやバイナリとして指定された他のファイルを保つ場合に生成される実行可能なプログラムのことであり、
単独では実行不可能なものの、他のプログラムを含むのには適しているライブラリターゲットとは一線を画す。
通常、クレートには、READMEファイルにクレートがライブラリかバイナリターゲットか、両方をもつかという情報がある。

cargo installでインストールされるバイナリは全てインストールルートのbinフォルダに保持される。
cargo --listでcargoで使えるコマンドを一覧で見ることが出来る。


Rustにおける一般的な種類のポインタは参照。
参照は&記号で示唆され、指している値を借用する。データを参照する以外に特別な能力はない。
オーバーヘッドがないので、ポインタの中では最も頻繁に使われる。

スマートポインタはポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造。
このポインタのおかげでデータに複数の所有者を持たせることが出来る。
所有者の数を追いかけ、所有者がいなくなったらデータの片付けをしてくれる。

Rustにおける参照とスマートポインタの違いとして、参照はデータを借用するだけのポインタである一方、
スマートポインタは指しているデータを借用する。

過去に上げられている例としてはStringやVec<T>がスマートポインタに数えられる。
これらはあるメモリを所有し、それを弄ることが出来る。
また、メタデータや追加の能力、あるいは保証（Stringならデータが常に有効なUTF-8であると保証することなど）もある。

スマートポインタは普通、構造体を使用して実装されている。
スマートポインタの通常の構造体と違う点としては、スマートポインタはDerefとDropトレイトを実装していること。
Defrefトレイトにより、スマートポインタ構造体のインスタンスは参照のように振る舞うことが出来る。
これにより参照あるいはスマートポインタのどちらとも動作するコードを書くことが出来る。
Dropトレイトにより、スマートポインタのインスタンスがスコープを外れたときに走るコードをカスタマイズすることが出来る。

最も素直なスマートポインタはボックスであり、その型はBox<T>と記述される。
ボックスにより、スタックではなくヒープにデータを格納することが出来る。
スタックに残るのはヒープデータへのポインタ。

ボックスにはデータをスタックの代わりにヒープを格納する以外には、パフォーマンスのオーバーヘッドはない。
しかし、以下のような場面では役に立つ。
・コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈で、その型の値を使用する時
・多くのデータが有り、その所有権を移したいが、その際にデータがコピーされないようにしたい時
・値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時

2つ目においてはデータ量が多いときは、パフォーマンスのためにスタック上でコピーしないようにするという解決方法。
コピーされるのはポインタのデータのみがスタック上でコピーされる。参照されているデータはコピーされることなくヒープ上の一箇所にとどまる。

let b = Box::new(5);
Boxは値5を指し、この値はヒープに確保されている。
mainの終わりにおいてボックスはメモリから開放されるが、スタック上のボックスとヒープに格納されているデータに対して解放が起こる。

コンパイル時にサイズがわからない方の一つとして再帰的な型がある。
この型の値は、値の一部として同じ型の他の値を持つ場合がある。値のネストにより理論的には無限に続く可能性がある。
コンパイラは再帰的な方の値が必要とする領域を知ることはできないが、ボックスのサイズは分かっているので、
再帰的な型の定義にボックスを挟むことで再帰的な型を作ることが出来る。

コンスリストは2つの引数から新しいペアを構成する。
この引数は通常単独の値と別のペアからなる。
コンスリストの各要素は2つの要素を含む。現在の要素の値と次の要素。
リストの最後の要素はNilと呼ばれる値だけを含み、次の要素を持たない。
コンスリストは繰り返しcons関数を呼び出すことで生成される。
繰り返しの既定ケースを示すのに標準t系に使われる名前はNil。
これはnullやnilの概念とは異なることに注意。nullやnilは無効だったり存在しない値。

関数型プログラミング言語ではコンスリストは頻繁に使われるが、RustではVec<T>を使用するのがよりよい選択になるのであまり使用されない。

enum List{
    Cons(i32,List),
    Nil,
}

このList型の使用には以下のような形になる
use List::{Cons,Nil};

fn main(){
    let list = Cons(1,Cons(2,Cons(3,Nil)));
}

このままでは「型が無限のサイズである」というコンパイルエラーが出る。
Box<T>はポインタのため、コンパイラはBox<T>が必要とする領域が必ずわかる。
ポインタのサイズは指しているデータの量に左右されないので、List値を直接置く代わりにBox<T>を配置することが出来る。

enum List{
    Cons(i32,Box<List>),
    Nil,
}

use List::{Cons,Nil};

fn main(){
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}

この形ならコンパイルエラーは起こらない。